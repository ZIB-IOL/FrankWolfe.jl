<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · FrankWolfe.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FrankWolfe.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="examples2.html">Examples</a></li><li class="is-active"><a class="tocitem" href="reference.html">Reference</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#LMOs"><span>LMOs</span></a></li><li><a class="tocitem" href="#Functions-and-Structures"><span>Functions and Structures</span></a></li><li class="toplevel"><a class="tocitem" href="#Components"><span>Components</span></a></li><li><a class="tocitem" href="#Functions-and-Structures-2"><span>Functions and Structures</span></a></li></ul></li><li><a class="tocitem" href="indexlist.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reference.html">Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reference.html">Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/j-geuter/FrankWolfe.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><p>This section contains all algorithms of the <a href="https://github.com/ZIB-IOL/FrankWolfe.jl"><code>FrankWolfe.jl</code></a> package.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>blended_conditional_gradient</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point" href="#FrankWolfe.compute_extreme_point"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_extreme_point(lmo::LinearMinimizationOracle, direction; kwargs...)</code></pre><p>Computes the point <code>argmin_{v ∈ C} v ⋅ direction</code> with <code>C</code> the set represented by the LMO. All LMOs should accept keyword arguments that they can ignore.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>frank_wolfe</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>lazified_conditional_gradient</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>away_frank_wolfe</code>. Check Documenter&#39;s build log for details.</p></div></div><h1 id="LMOs"><a class="docs-heading-anchor" href="#LMOs">LMOs</a><a id="LMOs-1"></a><a class="docs-heading-anchor-permalink" href="#LMOs" title="Permalink"></a></h1><p>The Linear Minimization Oracle (LMO) is an integral part of the iterative step in the FW algorithm. Given <span>$d\in \mathcal{X}$</span>, it returns:</p><p class="math-container">\[v\in \argmin_{x\in \mathcal{C}} \langle d,x \rangle.\]</p><p><a href="https://github.com/ZIB-IOL/FrankWolfe.jl"><code>FrankWolfe.jl</code></a> features the following common LMOs out of the box:</p><ul><li>probability simplex: <a href="reference.html#FrankWolfe.ProbabilitySimplexOracle"><code>FrankWolfe.ProbabilitySimplexOracle</code></a></li><li>unit simplex: <a href="reference.html#FrankWolfe.UnitSimplexOracle"><code>FrankWolfe.UnitSimplexOracle</code></a></li><li><span>$K$</span>-sparse polytope: <a href="reference.html#FrankWolfe.KSparseLMO"><code>FrankWolfe.KSparseLMO</code></a></li><li><span>$K$</span>-norm ball: <a href="reference.html#FrankWolfe.KNormBallLMO"><code>FrankWolfe.KNormBallLMO</code></a></li><li><span>$L^p$</span>-norm ball: <a href="reference.html#FrankWolfe.LpNormLMO"><code>FrankWolfe.LpNormLMO</code></a></li><li>Birkhoff polytope: <a href="reference.html#FrankWolfe.BirkhoffPolytopeLMO"><code>FrankWolfe.BirkhoffPolytopeLMO</code></a></li></ul><p>All of them are subtypes of <a href="reference.html#FrankWolfe.LinearMinimizationOracle"><code>FrankWolfe.LinearMinimizationOracle</code></a> and implement the <a href="reference.html#FrankWolfe.compute_extreme_point"><code>compute_extreme_point</code></a> method.</p><h2 id="Functions-and-Structures"><a class="docs-heading-anchor" href="#Functions-and-Structures">Functions and Structures</a><a id="Functions-and-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LinearMinimizationOracle" href="#FrankWolfe.LinearMinimizationOracle"><code>FrankWolfe.LinearMinimizationOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for linear minimization oracles.</p><p>All LMOs must implement <code>compute_extreme_point(lmo::LMO, direction)</code> and return a vector <code>v</code> of the appropriate type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.CachedLinearMinimizationOracle" href="#FrankWolfe.CachedLinearMinimizationOracle"><code>FrankWolfe.CachedLinearMinimizationOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CachedLinearMinimizationOracle{LMO}</code></pre><p>Oracle wrapping another one of type lmo. Subtypes of <code>CachedLinearMinimizationOracle</code> contain a cache of previous solutions.</p><p>By convention, the inner oracle is named <code>inner</code>. Cached optimizers are expected to implement <code>Base.empty!</code> and <code>Base.length</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.SingleLastCachedLMO" href="#FrankWolfe.SingleLastCachedLMO"><code>FrankWolfe.SingleLastCachedLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleLastCachedLMO{LMO, VT}</code></pre><p>Caches only the last result from an LMO and stores it in <code>last_vertex</code>. Vertices of <code>LMO</code> have to be of type <code>VT</code> if provided.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MultiCacheLMO" href="#FrankWolfe.MultiCacheLMO"><code>FrankWolfe.MultiCacheLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiCacheLMO{N, LMO, VT}</code></pre><p>Cache for a LMO storing up to <code>N</code> vertices in the cache, removed in FIFO style. <code>oldest_idx</code> keeps track of the oldest index in the tuple, i.e. to replace next. <code>VT</code>, if provided, must be the type of vertices returned by <code>LMO</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.VectorCacheLMO" href="#FrankWolfe.VectorCacheLMO"><code>FrankWolfe.VectorCacheLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorCacheLMO{N, LMO, VT}</code></pre><p>Cache for a LMO storing an unbounded number of vertices of type <code>VT</code> in the cache. <code>VT</code>, if provided, must be the type of vertices returned by <code>LMO</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ProductLMO" href="#FrankWolfe.ProductLMO"><code>FrankWolfe.ProductLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProductLMO(lmos...)</code></pre><p>Linear minimization oracle over the Cartesian product of multiple LMOs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.ProductLMO, Tuple}" href="#FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.ProductLMO, Tuple}"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_extreme_point(lmo::ProductLMO, direction::Tuple; kwargs...)</code></pre><p>Extreme point computation on Cartesian product, with a direction <code>(d1, d2, ...)</code> given as a tuple of directions. All keyword arguments are passed to all LMOs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{N}, Tuple{FrankWolfe.ProductLMO{N, TL} where TL&lt;:Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, AbstractArray}} where N" href="#FrankWolfe.compute_extreme_point-Union{Tuple{N}, Tuple{FrankWolfe.ProductLMO{N, TL} where TL&lt;:Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, AbstractArray}} where N"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_extreme_point(lmo::ProductLMO, direction::AbstractArray; direction_indices, storage=similar(direction))</code></pre><p>Extreme point computation, with a direction array and <code>direction_indices</code> provided such that: <code>direction[direction_indices[i]]</code> is passed to the i-th LMO. The result is stored in the optional <code>storage</code> container.</p><p>All keyword arguments are passed to all LMOs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.UnitSimplexOracle" href="#FrankWolfe.UnitSimplexOracle"><code>FrankWolfe.UnitSimplexOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnitSimplexOracle(right_side)</code></pre><p>Represents the scaled unit simplex:</p><pre><code class="language-none">C = {x ∈ R^n_+, ∑x ≤ right_side}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T" href="#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LMO for scaled unit simplex: <code>∑ x_i = τ</code> Returns either vector of zeros or vector with one active value equal to RHS if there exists an improving direction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T" href="#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T"><code>FrankWolfe.compute_dual_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual costs for a given primal solution to form a primal dual pair for scaled unit simplex. Returns two vectors. The first one is the dual costs associated with the constraints  and the second is the reduced costs for the variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ProbabilitySimplexOracle" href="#FrankWolfe.ProbabilitySimplexOracle"><code>FrankWolfe.ProbabilitySimplexOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProbabilitySimplexOracle(right_side)</code></pre><p>Represents the scaled probability simplex:</p><pre><code class="language-none">C = {x ∈ R^n_+, ∑x = right_side}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T" href="#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LMO for scaled probability simplex. Returns a vector with one active value equal to RHS in the most improving (or least degrading) direction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T" href="#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T"><code>FrankWolfe.compute_dual_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual costs for a given primal solution to form a primal dual pair for scaled probability simplex. Returns two vectors. The first one is the dual costs associated with the constraints  and the second is the reduced costs for the variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.KSparseLMO" href="#FrankWolfe.KSparseLMO"><code>FrankWolfe.KSparseLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KSparseLMO{T}(K::Int, right_hand_side::T)</code></pre><p>LMO for the K-sparse polytope:</p><pre><code class="language-none">C = B_1(τK) ∩ B_∞(τ)</code></pre><p>with <code>τ</code> the <code>right_hand_side</code> parameter. The LMO results in a vector with the K largest absolute values of direction, taking values <code>-τ sign(x_i)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.BirkhoffPolytopeLMO" href="#FrankWolfe.BirkhoffPolytopeLMO"><code>FrankWolfe.BirkhoffPolytopeLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BirkhoffPolytopeLMO</code></pre><p>The Birkhoff polytope encodes doubly stochastic matrices. Its extreme vertices are all permutation matrices of side-dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LpNormLMO" href="#FrankWolfe.LpNormLMO"><code>FrankWolfe.LpNormLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LpNormLMO{T, p}(right_hand_side)</code></pre><p>LMO with feasible set being a bound on the L-p norm:</p><pre><code class="language-none">C = {x ∈ R^n, norm(x, p) ≤ right_side}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.KNormBallLMO" href="#FrankWolfe.KNormBallLMO"><code>FrankWolfe.KNormBallLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KNormBallLMO{T}(K::Int, right_hand_side::T)</code></pre><p>LMO for the K-norm ball, intersection of L<em>1-ball (τK) and L</em>∞-ball (τ/K)</p><pre><code class="language-none">C_{K,τ} = conv { B_1(τ) ∪ B_∞(τ / K) }</code></pre><p>with <code>τ</code> the <code>right_hand_side</code> parameter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.NuclearNormLMO" href="#FrankWolfe.NuclearNormLMO"><code>FrankWolfe.NuclearNormLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NuclearNormLMO{T}(δ)</code></pre><p>LMO over matrices that have a nuclear norm less than δ. The LMO returns the rank-one matrix with singular value δ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.NuclearNormLMO, AbstractMatrix{T} where T}" href="#FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.NuclearNormLMO, AbstractMatrix{T} where T}"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Best rank-one approximation using the Golub-Kahan-Lanczos bidiagonalization from IterativeSolvers.</p><p>Warning: this does not work (yet) with all number types, BigFloat and Float16 fail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MathOptLMO" href="#FrankWolfe.MathOptLMO"><code>FrankWolfe.MathOptLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MathOptLMO{OT &lt;: MOI.Optimizer} &lt;: LinearMinimizationOracle</code></pre><p>Linear minimization oracle with feasible space defined through a MathOptInterface.Optimizer. The oracle call sets the direction and reruns the optimizer.</p><p>The <code>direction</code> vector has to be set in the same order of variables as the <code>MOI.ListOfVariableIndices()</code> getter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.convert_mathopt" href="#FrankWolfe.convert_mathopt"><code>FrankWolfe.convert_mathopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert_mathopt(lmo::LMO, optimizer::OT; kwargs...) -&gt; MathOptLMO{OT}</code></pre><p>Converts the given LMO to its equivalent MathOptInterface representation using <code>optimizer</code>. Must be implemented by LMOs.</p></div></section></article><h1 id="Components"><a class="docs-heading-anchor" href="#Components">Components</a><a id="Components-1"></a><a class="docs-heading-anchor-permalink" href="#Components" title="Permalink"></a></h1><p>This section gathers all additional relevant components of the <a href="https://github.com/ZIB-IOL/FrankWolfe.jl"><code>FrankWolfe.jl</code></a> package.</p><h2 id="Functions-and-Structures-2"><a class="docs-heading-anchor" href="#Functions-and-Structures-2">Functions and Structures</a><a class="docs-heading-anchor-permalink" href="#Functions-and-Structures-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ActiveSet" href="#FrankWolfe.ActiveSet"><code>FrankWolfe.ActiveSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ActiveSet{AT, R, IT}</code></pre><p>Represents an active set of extreme vertices collected in a FW algorithm, along with their coefficients <code>(λ_i, a_i)</code>. <code>R</code> is the type of the <code>λ_i</code>, <code>AT</code> is the type of the atoms <code>a_i</code>. The iterate <code>x = ∑λ_i a_i</code> is stored in x with type <code>IT</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_update!" href="#FrankWolfe.active_set_update!"><code>FrankWolfe.active_set_update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">active_set_update!(active_set::ActiveSet, lambda, atom)</code></pre><p>Adds the atom to the active set with weight lambda or adds lambda to existing atom.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_active_set_iterate" href="#FrankWolfe.compute_active_set_iterate"><code>FrankWolfe.compute_active_set_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_active_set_iterate(active_set)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_argmin" href="#FrankWolfe.active_set_argmin"><code>FrankWolfe.active_set_argmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">active_set_argmin(active_set::ActiveSet, direction)</code></pre><p>Computes the linear minimizer in the direction on the active set. Returns <code>(λ_i, a_i, i)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_argminmax" href="#FrankWolfe.active_set_argminmax"><code>FrankWolfe.active_set_argminmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">active_set_argminmax(active_set::ActiveSet, direction)</code></pre><p>Computes the linear minimizer in the direction on the active set. Returns <code>(λ_min, a_min, i_min, λ_max, a_max, i_max)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.find_minmax_directions" href="#FrankWolfe.find_minmax_directions"><code>FrankWolfe.find_minmax_directions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_minmax_directions(active_set::ActiveSet, direction, Φ)</code></pre><p>Computes the point of the active set minimizing in <code>direction</code> on the active set (local Frank Wolfe) and the maximizing one (away step). Returns the two corresponding indices in the active set, along with a flag indicating if the direction improvement is above a threshold. <code>goodstep_tolerance ∈ (0, 1]</code> is a tolerance coefficient multiplying Φ for the validation of the progress. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.minimize_over_convex_hull!" href="#FrankWolfe.minimize_over_convex_hull!"><code>FrankWolfe.minimize_over_convex_hull!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimize_over_convex_hull!</code></pre><p>Given a function f with gradient grad! and an active set  active_set this function will minimize the function over  the convex hull of the active set until the strong-wolfe  gap over the active set is below tolerance.</p><p>It will either directly minimize over the convex hull using simplex gradient descent, or it will transform the problem  to barycentric coordinates and minimize over the unit  probability simplex using gradient descent or Nesterov&#39;s  accelerated gradient descent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}" href="#FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}"><code>FrankWolfe.build_reduced_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_reduced_problem(atoms::AbstractVector{&lt;:FrankWolfe.ScaledHotVector}, hessian, weights, gradient, tolerance)</code></pre><p>Given an active set formed by ScaledHotVector, a (constant) Hessian and a gradient constructs a quadratic problem  over the unit probability simplex that is equivalent to  minimizing the original function over the convex hull of the active set. If λ are the barycentric coordinates of dimension equal to the cardinality of the active set, the objective  function is:     f(λ) = reduced<em>linear^T λ + 0.5 * λ^T reduced</em>hessian λ</p><p>In the case where we find that the current iterate has a strong-Wolfe  gap over the convex hull of the active set that is below the tolerance  we return nothing (as there is nothing to do).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:AbstractSparseArray, Any, Any, Any, Any}" href="#FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:AbstractSparseArray, Any, Any, Any, Any}"><code>FrankWolfe.build_reduced_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>build<em>reduced</em>problem</p><p>Same as the function above, but for the case where the active  set is formed by Sparse Arrays.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Array, Any, Any, Any, Any}" href="#FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Array, Any, Any, Any, Any}"><code>FrankWolfe.build_reduced_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_reduced_problem(atoms::AbstractVector{&lt;:Array}, hessian, weights, gradient, tolerance)</code></pre><p>Same as the two function above, but for the case where the active  set is formed by dense Arrays.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.Strong_Frank_Wolfe_gap" href="#FrankWolfe.Strong_Frank_Wolfe_gap"><code>FrankWolfe.Strong_Frank_Wolfe_gap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Checks the strong Frank-Wolfe gap for the reduced problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex" href="#FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex"><code>FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accelerated_simplex_gradient_descent_over_probability_simplex</code></pre><p>Minimizes an objective function over the unit probability simplex  until the Strong-Wolfe gap is below tolerance using Nesterov&#39;s  accelerated gradient descent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.simplex_gradient_descent_over_probability_simplex" href="#FrankWolfe.simplex_gradient_descent_over_probability_simplex"><code>FrankWolfe.simplex_gradient_descent_over_probability_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><p>simplex<em>gradient</em>descent<em>over</em>probability_simplex</p><p>Minimizes an objective function over the unit probability simplex  until the Strong-Wolfe gap is below tolerance using gradient descent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.projection_simplex_sort" href="#FrankWolfe.projection_simplex_sort"><code>FrankWolfe.projection_simplex_sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">projection_simplex_sort(x; s=1.0)</code></pre><p>Perform a projection onto the probability simplex of radius <code>s</code> using a sorting algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.Strong_Frank_Wolfe_gap_probability_simplex" href="#FrankWolfe.Strong_Frank_Wolfe_gap_probability_simplex"><code>FrankWolfe.Strong_Frank_Wolfe_gap_probability_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Strong<em>Frank</em>Wolfe<em>gap</em>probability_simplex</p><p>Compute the Strong-Wolfe gap over the unit probability simplex  given a gradient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.simplex_gradient_descent_over_convex_hull" href="#FrankWolfe.simplex_gradient_descent_over_convex_hull"><code>FrankWolfe.simplex_gradient_descent_over_convex_hull</code></a> — <span class="docstring-category">Function</span></header><section><div><p>simplex<em>gradient</em>descent<em>over</em>convex_hull</p><p>Minimizes an objective function over the convex hull of the active set until the Strong-Wolfe gap is below tolerance using simplex gradient descent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.lp_separation_oracle" href="#FrankWolfe.lp_separation_oracle"><code>FrankWolfe.lp_separation_oracle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns either a tuple <code>(y, val)</code> with <code>y</code> an atom from the active set satisfying the progress criterion and <code>val</code> the corresponding gap <code>dot(y, direction)</code> or the same tuple with <code>y</code> from the LMO.</p><p><code>inplace_loop</code> controls whether the iterate type allows in-place writes. <code>kwargs</code> are passed on to the LMO oracle.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LineSearchMethod" href="#FrankWolfe.LineSearchMethod"><code>FrankWolfe.LineSearchMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Line search method to apply once the direction is computed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.Emphasis" href="#FrankWolfe.Emphasis"><code>FrankWolfe.Emphasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Emphasis given to the algorithm for memory-saving or not. The memory-saving mode may not be faster than the default blas mode for small dimensions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ObjectiveFunction" href="#FrankWolfe.ObjectiveFunction"><code>FrankWolfe.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveFunction{VT}</code></pre><p>Represents an objective function optimized by algorithms. Subtypes of <code>ObjectiveFunction</code> must implement at least</p><ul><li><code>compute_value(::ObjectiveFunction, x)</code> for primal value evaluation</li><li><code>compute_gradient(::ObjectiveFunction, x)</code> for gradient evaluation.</li></ul><p>and optionally <code>compute_value_gradient(::ObjectiveFunction, x)</code> returning the (primal, gradient) pair.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_value_gradient" href="#FrankWolfe.compute_value_gradient"><code>FrankWolfe.compute_value_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_value_gradient(f::ObjectiveFunction, x; kwargs)</code></pre><p>Computes in one call the pair <code>(function_value, function_grad)</code> evaluated at <code>x</code>. By default, calls <code>compute_value</code> and <code>compute_gradient</code> with keyword <code>kwargs</code> passed to both.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.StochasticObjective" href="#FrankWolfe.StochasticObjective"><code>FrankWolfe.StochasticObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StochasticObjective{F, G, XT}(f::F, grad::G, xs::XT)</code></pre><p>Represents an objective function evaluated with stochastic gradient. <code>f(θ, x)</code> evaluates the loss for data point <code>x</code> and parameter <code>θ</code>. <code>grad(θ, x)</code> evaluates the loss gradient with respect to data point <code>x</code> at parameter <code>θ</code>. <code>xs</code> must be an indexable iterable (<code>Vector{Vector{Float64}}</code> for instance). Functions using a <code>StochasticObjective</code> have optional keyword arguments <code>rng</code>, <code>batch_size</code> and <code>full_evaluation</code> controlling whether the function should be evaluated over all data points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ScaledHotVector" href="#FrankWolfe.ScaledHotVector"><code>FrankWolfe.ScaledHotVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScaledHotVector{T}</code></pre><p>Represents a vector of at most one value different from 0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.RankOneMatrix" href="#FrankWolfe.RankOneMatrix"><code>FrankWolfe.RankOneMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RankOneMatrix{T, UT, VT}</code></pre><p>Represents a rank-one matrix <code>R = u * vt&#39;</code>. Composes like a charm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.line_search_wrapper" href="#FrankWolfe.line_search_wrapper"><code>FrankWolfe.line_search_wrapper</code></a> — <span class="docstring-category">Function</span></header><section><div><p>line search wrapper NOTE: The stepsize is defined as x - gamma * d</p><p>Returns the step size gamma and the Lipschitz estimate L</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.adaptive_step_size" href="#FrankWolfe.adaptive_step_size"><code>FrankWolfe.adaptive_step_size</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Slight modification of Adaptive Step Size strategy from https://arxiv.org/pdf/1806.05123.pdf</p><p>Note: direction is opposite to the improving direction norm(gradient, direction) &gt; 0 TODO: </p><ul><li>make emphasis aware and optimize</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.plot_results" href="#FrankWolfe.plot_results"><code>FrankWolfe.plot_results</code></a> — <span class="docstring-category">Function</span></header><section><div><p>plot_results</p><p>Given a series of list, generate subplots. list<em>data</em>y -&gt; contains a list of a list of lists (where each list refers to a subplot, and a list of lists refers to the y-values of the series inside a subplot). list<em>data</em>x -&gt; contains a list of a list of lists (where each list refers to a subplot, and a list of lists refers to the x-values of the series inside a subplot). So if we have one plot with two series, these might look like:     list<em>data</em>y = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]     list<em>data</em>x = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]</p><p>And if we have two plots, each with two series, these might look like:     list<em>data</em>y = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11, 12], [7, 8, 9, 10, 11, 12]]]     list<em>data</em>x = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11, 12], [7, 8, 9, 10, 11, 12]]]</p><p>list<em>label -&gt; contains the labels for the series that will be plotted, which has to have a length equal to the number of series that are being plotted:     list</em>label = [&quot;Series 1&quot;, &quot;Series 2&quot;]</p><p>list<em>axis</em>x -&gt; contains the labels for the x-axis that will be plotted,  which has to have a length equal to the number of subplots:      list<em>axis</em>x = [&quot;x-axis plot 1&quot;, &quot;x-axis plot 1&quot;]</p><p>list<em>axis</em>y -&gt; Same as list<em>axis</em>x but for the y-axis</p><p>xscalelog -&gt; A list of values indicating the type of axes to use in each subplot, must be equal to the number of subplots:     xscalelog = [:log, :identity]</p><p>yscalelog -&gt; Same as xscalelog but for the y-axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe._unsafe_equal" href="#FrankWolfe._unsafe_equal"><code>FrankWolfe._unsafe_equal</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isequal</code> without the checks. Assumes a and b have the same axes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.check_gradients" href="#FrankWolfe.check_gradients"><code>FrankWolfe.check_gradients</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if the gradient using finite differences matches the grad! provided.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.trajectory_callback" href="#FrankWolfe.trajectory_callback"><code>FrankWolfe.trajectory_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trajectory_callback(storage)</code></pre><p>Callback pushing the state at each iteration to the passed storage. The state data is only the 5 first fields, usually: <code>(t,primal,dual,dual_gap,time)</code></p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples2.html">« Examples</a><a class="docs-footer-nextpage" href="indexlist.html">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 11 June 2021 18:53">Friday 11 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
