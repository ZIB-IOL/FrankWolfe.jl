var documenterSearchIndex = {"docs":
[{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/#Extra-lazification","page":"Extra-lazification","title":"Extra-lazification","text":"","category":"section"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"Sometimes the Frank-Wolfe algorithm will be run multiple times with slightly different settings under which vertices collected in a previous run are still valid.","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"The extra-lazification feature can be used for this purpose. It consists of a storage that can collect dropped vertices during a run, and the ability to use these vertices in another run, when they are not part of the current active set. The vertices that are part of the active set do not need to be duplicated in the extra-lazification storage. The extra-vertices can be used instead of calling the LMO when it is a relatively expensive operation.","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"using FrankWolfe\nusing Test\nusing LinearAlgebra","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"We will use a parameterized objective function 12 x - c^2 over the unit simplex.","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"const n = 100\nconst center0 = 5.0 .+ 3 * rand(n)\nf(x) = 0.5 * norm(x .- center0)^2\nfunction grad!(storage, x)\n    return storage .= x .- center0\nend","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"The TrackingLMO will let us count how many real calls to the LMO are performed by a single run of the algorithm.","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"lmo = FrankWolfe.UnitSimplexOracle(4.3)\ntlmo = FrankWolfe.TrackingLMO(lmo)\nx0 = FrankWolfe.compute_extreme_point(lmo, randn(n));\nnothing #hide","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/#Adding-a-vertex-storage","page":"Extra-lazification","title":"Adding a vertex storage","text":"","category":"section"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"FrankWolfe offers a simple FrankWolfe.DeletedVertexStorage storage type which has as parameter return_kth, the number of good directions to find before returning the best. return_kth larger than the number of vertices means that the best-aligned vertex will be found. return_kth = 1 means the first acceptable vertex (with the specified threhsold) is returned.","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"See FrankWolfe.DeletedVertexStorage","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"vertex_storage = FrankWolfe.DeletedVertexStorage(typeof(x0)[], 5)\ntlmo.counter = 0\n\nresults = FrankWolfe.blended_pairwise_conditional_gradient(\n    f,\n    grad!,\n    tlmo,\n    x0,\n    max_iteration=4000,\n    verbose=true,\n    lazy=true,\n    epsilon=1e-5,\n    add_dropped_vertices=true,\n    extra_vertex_storage=vertex_storage,\n)","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"The counter indicates the number of initial calls to the LMO. We will now construct different objective functions based on new centers, call the BPCG algorithm while accumulating vertices in the storage, in addition to warm-starting with the active set of the previous iteration. This allows for a \"double-warmstarted\" algorithm, reducing the number of LMO calls from one problem to the next.","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"active_set = results[end]\ntlmo.counter\n\nfor iter in 1:10\n    center = 5.0 .+ 3 * rand(n)\n    f_i(x) = 0.5 * norm(x .- center)^2\n    function grad_i!(storage, x)\n        return storage .= x .- center\n    end\n    tlmo.counter = 0\n    FrankWolfe.blended_pairwise_conditional_gradient(\n        f_i,\n        grad_i!,\n        tlmo,\n        active_set,\n        max_iteration=4000,\n        lazy=true,\n        epsilon=1e-5,\n        add_dropped_vertices=true,\n        use_extra_vertex_storage=true,\n        extra_vertex_storage=vertex_storage,\n        verbose=false,\n    )\n    @info \"Number of LMO calls in iter $iter: $(tlmo.counter)\"\n    @info \"Vertex storage size: $(length(vertex_storage.storage))\"\nend","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"","category":"page"},{"location":"examples/docs_09_extra_vertex_storage/","page":"Extra-lazification","title":"Extra-lazification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_02_polynomial_regression/#Polynomial-Regression","page":"Polynomial Regression","title":"Polynomial Regression","text":"","category":"section"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"The following example features the LMO for polynomial regression on the ell_1 norm ball. Given input/output pairs x_iy_i_i=1^N and sparse coefficients c_j, where","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"y_i=sum_j=1^m c_j f_j(x_i)","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"and f_j mathbbR^ntomathbbR, the task is to recover those c_j that are non-zero alongside their corresponding values. Under certain assumptions, this problem can be convexified into","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"min_cinmathcalCy-Ac^2","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"for a convex set mathcalC. It can also be found as example 4.1 in the paper. In order to evaluate the polynomial, we generate a total of 1000 data points x_i_i=1^N from the standard multivariate Gaussian, with which we will compute the output variables y_i_i=1^N. Before evaluating the polynomial, these points will be contaminated with noise drawn from a standard multivariate Gaussian. We run the away_frank_wolfe and blended_conditional_gradient algorithms, and compare them to Projected Gradient Descent using a smoothness estimate. We will evaluate the output solution on test points drawn in a similar manner as the training points.","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"using FrankWolfe\n\nusing LinearAlgebra\nimport Random\n\nusing MultivariatePolynomials\nusing DynamicPolynomials\n\nusing Plots\n\nusing LaTeXStrings\n\nconst N = 10\n\nDynamicPolynomials.@polyvar X[1:15]\n\nconst max_degree = 4\ncoefficient_magnitude = 10\nnoise_magnitude = 1\n\nconst var_monomials = MultivariatePolynomials.monomials(X, 0:max_degree)\n\nRandom.seed!(42)\nconst all_coeffs = map(var_monomials) do m\n    d = MultivariatePolynomials.degree(m)\n    return coefficient_magnitude * rand() .* (rand() .> 0.95 * d / max_degree)\nend\n\nconst true_poly = dot(all_coeffs, var_monomials)\n\nconst training_data = map(1:500) do _\n    x = 0.1 * randn(N)\n    y = MultivariatePolynomials.subs(true_poly, Pair(X, x)) + noise_magnitude * randn()\n    return (x, y.a[1])\nend\n\nconst extended_training_data = map(training_data) do (x, y)\n    x_ext = MultivariatePolynomials.coefficient.(MultivariatePolynomials.subs.(var_monomials, X => x))\n    return (x_ext, y)\nend\n\nconst test_data = map(1:1000) do _\n    x = 0.4 * randn(N)\n    y = MultivariatePolynomials.subs(true_poly, Pair(X, x)) + noise_magnitude * randn()\n    return (x, y.a[1])\nend\n\nconst extended_test_data = map(test_data) do (x, y)\n    x_ext = MultivariatePolynomials.coefficient.(MultivariatePolynomials.subs.(var_monomials, X => x))\n    return (x_ext, y)\nend\n\nfunction f(coefficients)\n    return 0.5 / length(extended_training_data) * sum(extended_training_data) do (x, y)\n        return (dot(coefficients, x) - y)^2\n    end\nend\n\nfunction f_test(coefficients)\n    return 0.5 / length(extended_test_data) * sum(extended_test_data) do (x, y)\n        return (dot(coefficients, x) - y)^2\n    end\nend\n\nfunction coefficient_errors(coeffs)\n    return 0.5 * sum(eachindex(all_coeffs)) do idx\n        return (all_coeffs[idx] - coeffs[idx])^2\n    end\nend\n\nfunction grad!(storage, coefficients)\n    storage .= 0\n    for (x, y) in extended_training_data\n        p_i = dot(coefficients, x) - y\n        @. storage += x * p_i\n    end\n    storage ./= length(training_data)\n    return nothing\nend\n\nfunction build_callback(trajectory_arr)\n    return function callback(state, args...)\n        return push!(\n            trajectory_arr,\n            (FrankWolfe.callback_state(state)..., f_test(state.x), coefficient_errors(state.x)),\n        )\n    end\nend\n\ngradient = similar(all_coeffs)\n\nmax_iter = 10000\nrandom_initialization_vector = rand(length(all_coeffs))\n\nlmo = FrankWolfe.LpNormLMO{1}(0.95 * norm(all_coeffs, 1))\n\n# Estimating smoothness parameter\nnum_pairs = 1000\nL_estimate = -Inf\ngradient_aux = similar(gradient)\n\nfor i in 1:num_pairs # hide\n    global L_estimate # hide\n    x = compute_extreme_point(lmo, randn(size(all_coeffs))) # hide\n    y = compute_extreme_point(lmo, randn(size(all_coeffs))) # hide\n    grad!(gradient, x) # hide\n    grad!(gradient_aux, y) # hide\n    new_L = norm(gradient - gradient_aux) / norm(x - y) # hide\n    if new_L > L_estimate # hide\n        L_estimate = new_L # hide\n    end # hide\nend # hide\n\nfunction projnorm1(x, τ)\n    n = length(x)\n    if norm(x, 1) ≤ τ\n        return x\n    end\n    u = abs.(x)\n    # simplex projection\n    bget = false\n    s_indices = sortperm(u, rev=true)\n    tsum = zero(τ)\n\n    @inbounds for i in 1:n-1\n        tsum += u[s_indices[i]]\n        tmax = (tsum - τ) / i\n        if tmax ≥ u[s_indices[i+1]]\n            bget = true\n            break\n        end\n    end\n    if !bget\n        tmax = (tsum + u[s_indices[n]] - τ) / n\n    end\n\n    @inbounds for i in 1:n\n        u[i] = max(u[i] - tmax, 0)\n        u[i] *= sign(x[i])\n    end\n    return u\nend\nxgd = FrankWolfe.compute_extreme_point(lmo, random_initialization_vector) # hide\ntraining_gd = Float64[] # hide\ntest_gd = Float64[] # hide\ncoeff_error = Float64[] # hide\ntime_start = time_ns() # hide\ngd_times = Float64[] # hide\nfor iter in 1:max_iter # hide\n    global xgd # hide\n    grad!(gradient, xgd) # hide\n    xgd = projnorm1(xgd - gradient / L_estimate, lmo.right_hand_side) # hide\n    push!(training_gd, f(xgd)) # hide\n    push!(test_gd, f_test(xgd)) # hide\n    push!(coeff_error, coefficient_errors(xgd)) # hide\n    push!(gd_times, (time_ns() - time_start) * 1e-9) # hide\nend # hide\n\nx00 = FrankWolfe.compute_extreme_point(lmo, random_initialization_vector) # hide\nx0 = deepcopy(x00) # hide\n\ntrajectory_lafw = [] # hide\ncallback = build_callback(trajectory_lafw) # hide\nx_lafw, v, primal, dual_gap, _ = FrankWolfe.away_frank_wolfe( # hide\n    f, # hide\n    grad!, # hide\n    lmo, # hide\n    x0, # hide\n    max_iteration=max_iter, # hide\n    line_search=FrankWolfe.Adaptive(L_est=L_estimate), # hide\n    print_iter=max_iter ÷ 10, # hide\n    memory_mode=FrankWolfe.InplaceEmphasis(), # hide\n    verbose=false, # hide\n    lazy=true, # hide\n    gradient=gradient, # hide\n    callback=callback, # hide\n) # hide\n\ntrajectory_bcg = [] # hide\ncallback = build_callback(trajectory_bcg) # hide\nx0 = deepcopy(x00) # hide\nx_bcg, v, primal, dual_gap, _, _ = FrankWolfe.blended_conditional_gradient( # hide\n    f, # hide\n    grad!, # hide\n    lmo, # hide\n    x0, # hide\n    max_iteration=max_iter, # hide\n    line_search=FrankWolfe.Adaptive(L_est=L_estimate), # hide\n    print_iter=max_iter ÷ 10, # hide\n    memory_mode=FrankWolfe.InplaceEmphasis(), # hide\n    verbose=false, # hide\n    weight_purge_threshold=1e-10, # hide\n    callback=callback, # hide\n) # hide\nx0 = deepcopy(x00) # hide\ntrajectory_lafw_ref = [] # hide\ncallback = build_callback(trajectory_lafw_ref) # hide\n_, _, primal_ref, _, _ = FrankWolfe.away_frank_wolfe( # hide\n    f, # hide\n    grad!, # hide\n    lmo, # hide\n    x0, # hide\n    max_iteration=2 * max_iter, # hide\n    line_search=FrankWolfe.Adaptive(L_est=L_estimate), # hide\n    print_iter=max_iter ÷ 10, # hide\n    memory_mode=FrankWolfe.InplaceEmphasis(), # hide\n    verbose=false, # hide\n    lazy=true, # hide\n    gradient=gradient, # hide\n    callback=callback, # hide\n) # hide\n\n\nfor i in 1:num_pairs\n    global L_estimate\n    x = compute_extreme_point(lmo, randn(size(all_coeffs)))\n    y = compute_extreme_point(lmo, randn(size(all_coeffs)))\n    grad!(gradient, x)\n    grad!(gradient_aux, y)\n    new_L = norm(gradient - gradient_aux) / norm(x - y)\n    if new_L > L_estimate\n        L_estimate = new_L\n    end\nend","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"We can now perform projected gradient descent:","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"xgd = FrankWolfe.compute_extreme_point(lmo, random_initialization_vector)\ntraining_gd = Float64[]\ntest_gd = Float64[]\ncoeff_error = Float64[]\ntime_start = time_ns()\ngd_times = Float64[]\nfor iter in 1:max_iter\n    global xgd\n    grad!(gradient, xgd)\n    xgd = projnorm1(xgd - gradient / L_estimate, lmo.right_hand_side)\n    push!(training_gd, f(xgd))\n    push!(test_gd, f_test(xgd))\n    push!(coeff_error, coefficient_errors(xgd))\n    push!(gd_times, (time_ns() - time_start) * 1e-9)\nend\n\nx00 = FrankWolfe.compute_extreme_point(lmo, random_initialization_vector)\nx0 = deepcopy(x00)\n\ntrajectory_lafw = []\ncallback = build_callback(trajectory_lafw)\nx_lafw, v, primal, dual_gap, _ = FrankWolfe.away_frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=max_iter,\n    line_search=FrankWolfe.Adaptive(L_est=L_estimate),\n    print_iter=max_iter ÷ 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=false,\n    lazy=true,\n    gradient=gradient,\n    callback=callback,\n)\n\ntrajectory_bcg = []\ncallback = build_callback(trajectory_bcg)\n\nx0 = deepcopy(x00)\nx_bcg, v, primal, dual_gap, _, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=max_iter,\n    line_search=FrankWolfe.Adaptive(L_est=L_estimate),\n    print_iter=max_iter ÷ 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=false,\n    weight_purge_threshold=1e-10,\n    callback=callback,\n)\n\nx0 = deepcopy(x00)\n\ntrajectory_lafw_ref = []\ncallback = build_callback(trajectory_lafw_ref)\n_, _, primal_ref, _, _ = FrankWolfe.away_frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=2 * max_iter,\n    line_search=FrankWolfe.Adaptive(L_est=L_estimate),\n    print_iter=max_iter ÷ 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=false,\n    lazy=true,\n    gradient=gradient,\n    callback=callback,\n)\n\niteration_list = [\n    [x[1] + 1 for x in trajectory_lafw],\n    [x[1] + 1 for x in trajectory_bcg],\n    collect(eachindex(training_gd)),\n]\ntime_list = [[x[5] for x in trajectory_lafw], [x[5] for x in trajectory_bcg], gd_times]\nprimal_list = [\n    [x[2] - primal_ref for x in trajectory_lafw],\n    [x[2] - primal_ref for x in trajectory_bcg],\n    [x - primal_ref for x in training_gd],\n]\ntest_list = [[x[6] for x in trajectory_lafw], [x[6] for x in trajectory_bcg], test_gd]\nlabel = [L\"\\textrm{L-AFW}\", L\"\\textrm{BCG}\", L\"\\textrm{GD}\"]\ncoefficient_error_values =\n    [[x[7] for x in trajectory_lafw], [x[7] for x in trajectory_bcg], coeff_error]\n\n\nplot_results(\n    [primal_list, primal_list, test_list, test_list],\n    [iteration_list, time_list, iteration_list, time_list],\n    label,\n    [L\"\\textrm{Iteration}\", L\"\\textrm{Time}\", L\"\\textrm{Iteration}\", L\"\\textrm{Time}\"],\n    [L\"\\textrm{Primal Gap}\", L\"\\textrm{Primal Gap}\", L\"\\textrm{Test loss}\", L\"\\textrm{Test loss}\"],\n    xscalelog=[:log, :identity, :log, :identity],\n    legend_position=[:bottomleft, nothing, nothing, nothing],\n)","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"","category":"page"},{"location":"examples/docs_02_polynomial_regression/","page":"Polynomial Regression","title":"Polynomial Regression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/#Tracking,-counters-and-custom-callbacks-for-Frank-Wolfe","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"","category":"section"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"In this example we will run the standard Frank-Wolfe algorithm while tracking the number of calls to the different oracles, namely function, gradient evaluations, and LMO calls. In order to track each of these metrics, a \"Tracking\" version of the Gradient, LMO and Function methods have to be supplied to the frank_wolfe algorithm, which are wrapping a standard one.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"using FrankWolfe\nusing Test\nusing LinearAlgebra\nusing FrankWolfe: ActiveSet","category":"page"},{"location":"examples/docs_08_callback_and_tracking/#The-trackers-for-primal-objective,-gradient-and-LMO.","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"The trackers for primal objective, gradient and LMO.","text":"","category":"section"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"In order to count the number of function calls, a TrackingObjective is built from a standard objective function f, which will act in the same way as the original function does, but with an additional .counter field which tracks the number of calls.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"f(x) = norm(x)^2\ntf = FrankWolfe.TrackingObjective(f)\n@show tf.counter\ntf(rand(3))\n@show tf.counter\n# Resetting the counter\ntf.counter = 0;\nnothing #hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"Similarly, the tgrad! function tracks the number of gradient calls:","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"function grad!(storage, x)\n    return storage .= 2x\nend\ntgrad! = FrankWolfe.TrackingGradient(grad!)\n@show tgrad!.counter;\nnothing #hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"The tracking LMO operates in a similar fashion and tracks the number of compute_extreme_point calls.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"lmo_prob = FrankWolfe.ProbabilitySimplexOracle(1)\ntlmo_prob = FrankWolfe.TrackingLMO(lmo_prob)\n@show tlmo_prob.counter;\nnothing #hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"The tracking LMO can be applied for all types of LMOs and even in a nested way, which can be useful to track the number of calls to a lazified oracle. We can now pass the tracking versions tf, tgrad and tlmo_prob to frank_wolfe and display their call counts after the optimization process.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"x0 = FrankWolfe.compute_extreme_point(tlmo_prob, ones(5))\nfw_results = FrankWolfe.frank_wolfe(\n    tf,\n    tgrad!,\n    tlmo_prob,\n    x0,\n    max_iteration=1000,\n    line_search=FrankWolfe.Agnostic(),\n    callback=nothing,\n)\n\n@show tf.counter\n@show tgrad!.counter\n@show tlmo_prob.counter;\nnothing #hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/#Adding-a-custom-callback","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Adding a custom callback","text":"","category":"section"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"A callback is a user-defined function called at every iteration of the algorithm with the current state passed as a named tuple.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"We can implement our own callback, for example with:","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"Extended trajectory logging, similar to the trajectory = true option\nStop criterion after a certain number of calls to the primal objective function","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"To reuse the same tracking functions, Let us first reset their counters:","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"tf.counter = 0\ntgrad!.counter = 0\ntlmo_prob.counter = 0;\nnothing #hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"The storage variable stores in the trajectory array the number of calls to each oracle at each iteration.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"storage = []","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"Now define our own trajectory logging function that extends the five default logged elements (iterations, primal, dual, dual_gap, time) with \".counter\" field arguments present in the tracking functions.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"function push_tracking_state(state, storage)\n    base_tuple = FrankWolfe.callback_state(state)\n    if state.lmo isa FrankWolfe.CachedLinearMinimizationOracle\n        complete_tuple = tuple(\n            base_tuple...,\n            state.gamma,\n            state.f.counter,\n            state.grad!.counter,\n            state.lmo.inner.counter,\n        )\n    else\n        complete_tuple = tuple(\n            base_tuple...,\n            state.gamma,\n            state.f.counter,\n            state.grad!.counter,\n            state.lmo.counter,\n        )\n    end\n    return push!(storage, complete_tuple)\nend","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"In case we want to stop the frank_wolfe algorithm prematurely after a certain condition is met, we can return a boolean stop criterion false. Here, we will implement a callback that terminates the algorithm if the primal objective function is evaluated more than 500 times.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"function make_callback(storage)\n    return function callback(state, args...)\n        push_tracking_state(state, storage)\n        return state.f.counter < 500\n    end\nend\n\ncallback = make_callback(storage)","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"We can show the difference between this standard run and the lazified conditional gradient algorithm which does not call the LMO at each iteration.","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"FrankWolfe.lazified_conditional_gradient(\n    tf,\n    tgrad!,\n    tlmo_prob,\n    x0,\n    max_iteration=1000,\n    traj_data=storage,\n    line_search=FrankWolfe.Agnostic(),\n    callback=callback,\n)\n\ntotal_iterations = storage[end][1]\n@show total_iterations\n@show tf.counter\n@show tgrad!.counter\n@show tlmo_prob.counter;\nnothing #hide","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"","category":"page"},{"location":"examples/docs_08_callback_and_tracking/","page":"Tracking, counters and custom callbacks for Frank Wolfe","title":"Tracking, counters and custom callbacks for Frank Wolfe","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributing-to-FrankWolfe","page":"Contributing","title":"Contributing to FrankWolfe","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"First, thanks for taking the time to contribute. Contributions in any form, such as documentation, bug fix, examples or algorithms, are appreciated and welcome.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We list below some guidelines to help you contribute to the package.","category":"page"},{"location":"contributing/#Community-Standards","page":"Contributing","title":"Community Standards","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Interactions on this repository must follow the Julia Community Standards including Pull Requests and issues.","category":"page"},{"location":"contributing/#Where-can-I-get-an-overview?","page":"Contributing","title":"Where can I get an overview?","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Check out the paper presenting the package for a high-level overview of the feature and algorithms and the documentation for more details.","category":"page"},{"location":"contributing/#I-just-have-a-question","page":"Contributing","title":"I just have a question","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If your question is related to Julia, its syntax or tooling, the best places to get help will be tied to the Julia community, see the Julia community page for a number of communication channels (Slack, Zulip, and Discourse being the most active).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For now, the best way to ask a question is to file an issue or reach out to Mathieu Besançon or Sebastian Pokutta. You can also ask your question on discourse.julialang.org in the optimization topic or on the Julia Slack on #mathematical-optimization, see the Julia community page to gain access.","category":"page"},{"location":"contributing/#How-can-I-file-an-issue?","page":"Contributing","title":"How can I file an issue?","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you found a bug or want to propose a feature, we track our issues within the GitHub repository. Once opened, you can edit the issue or add new comments to continue the conversation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you encounter a bug, send the stack trace (the lines appearing after the error occurred containing some source files) and ideally a Minimal Working Example (MWE), a small program that reproduces the bug.","category":"page"},{"location":"contributing/#How-can-I-contribute","page":"Contributing","title":"How can I contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributing to the repository will likely be made in a Pull Request (PR). You will need to:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Fork the repository\nClone it on your machine to perform the changes\nCreate a branch for your modifications, based on the branch you want to merge on (typically master)\nPush to this branch on your fork\nThe GitHub web interface will then automatically suggest opening a PR onto the original repository.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"See the GitHub guide to creating PRs for more help on workflows using Git and GitHub.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"A PR should do a single thing to reduce the amount of code that must be reviewed. Do not run the formatter on the whole repository except if your PR is specifically about formatting.","category":"page"},{"location":"contributing/#Improve-the-documentation","page":"Contributing","title":"Improve the documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The documentation can be improved by changing the files in docs/src, for example to add a section in the documentation, expand a paragraph or add a plot. The documentation attached to a given type of function can be modified in the source files directly, it appears above the function / type / thingy you try to document with three double quotation marks like this:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"\"\"\"\nThis explains what the function `f` does, it supports markdown.\n\"\"\"\nfunction f(x)\n    # ...\nend","category":"page"},{"location":"contributing/#Provide-a-new-example-or-test","page":"Contributing","title":"Provide a new example or test","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you fix a bug, one would typically expect to add a test that validates that the bug is gone. A test would be added in a file in the test/ folder, for which the entry point is runtests.jl.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The examples/ folder features several examples covering different problem settings and algorithms. The examples are expected to run with the same environment and dependencies as the tests using TestEnv. If the example is lightweight enough, it can be added to the docs/src/examples/ folder which generates pages for the documentation based on Literate.jl.","category":"page"},{"location":"contributing/#Provide-a-new-feature","page":"Contributing","title":"Provide a new feature","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributions bringing new features are also welcome. If the feature is likely to impact performance, some benchmarks should be run with BenchmarkTools on several of the examples to assert the effect at different problem sizes. If the feature should only be active in some cases, a keyword should be added to the main algorithms to support it.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Some typical features to implement are:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"A new Linear Minimization Oracle (LMO)\nA new step size\nA new algorithm (less frequent) following the same API.","category":"page"},{"location":"contributing/#Code-style","page":"Contributing","title":"Code style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We try to follow the Julia documentation guidelines. We run JuliaFormatter.jl on the repo in the way set in the .JuliaFormatter.toml file, which enforces a number of conventions.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This contribution guide was inspired by ColPrac and the one in Manopt.jl.","category":"page"},{"location":"basics/#How-does-it-work?","page":"How does it work?","title":"How does it work?","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"FrankWolfe.jl contains generic routines to solve optimization problems of the form","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"min_x in mathcalC f(x)","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where mathcalC is a compact convex set and f is a differentiable function. These routines work by solving a sequence of linear subproblems:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"min_x in mathcalC langle d_k x rangle quad textwhere quad d_k = nabla f(x_k)","category":"page"},{"location":"basics/#Linear-Minimization-Oracles","page":"How does it work?","title":"Linear Minimization Oracles","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Linear Minimization Oracle (LMO) is a key component, which is called at each iteration of the FW algorithm. Given a direction d, it returns an optimal vertex of the feasible set:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"v in argmin_xin mathcalC langle dx rangle","category":"page"},{"location":"basics/#Pre-defined-LMO-for-key-feasible-sets","page":"How does it work?","title":"Pre-defined LMO for key feasible sets","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Several common implementations of LMOS s are available out-of-the-box:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"simplices: unit simplex FrankWolfe.UnitSimplexOracle , probability simplex FrankWolfe.ProbabilitySimplexOracle;\nballs in various norms FrankWolfe.LpNormLMO;\npolytopes: K-sparse FrankWolfe.KSparseLMO , Birkhoff FrankWolfe.BirkhoffPolytopeLMO.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"See Combettes, Pokutta (2021) for references on most LMOs implemented in the package and their comparison with projection operators.","category":"page"},{"location":"basics/#The-MathOptLMO","page":"How does it work?","title":"The MathOptLMO","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"You can use an oracle defined via a Linear Programming solver (e.g. SCIP or HiGHS) with MathOptInferface: see FrankWolfe.MathOptLMO.","category":"page"},{"location":"basics/#Wrapper-to-combine-LMOs","page":"How does it work?","title":"Wrapper to combine LMOs","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"We provide wrappers to combine oracles easily, for example FrankWolfe.ProductLMO for product of oracles or FrankWolfe.SubspaceLMO for projections composed with oracles.","category":"page"},{"location":"basics/#User-defined-LMOs","page":"How does it work?","title":"User-defined LMOs","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"If you want use your own custom LMO MyLMO in the algorithms provided here, it is required that","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"MyLMO be a subtype of FrankWolfe.LinearMinimizationOracle;\nthe method FrankWolfe.compute_extreme_point (see below) be defined and minimize v mapsto langle d v rangle over the set mathcalC defined by the custom LMO MyLMO.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"FrankWolfe.compute_extreme_point(lmo::MyLMO, direction; v, kwargs...) -> v","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Note that the constraint set mathcalC defined by MyLMO doesn't have to be represented explicitly, e.g., as a set of inequalities. Indeed, all we need is to minimize a linear function over mathcalC, which does not necessarily require an explicit representation of mathcalC. Even black box minimization procedures can be considered!","category":"page"},{"location":"basics/#Optimization-algorithms","page":"How does it work?","title":"Optimization algorithms","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The package features several variants of Frank-Wolfe that share the same basic API.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Most of the algorithms listed below also have a lazified version: see Braun, Pokutta, Zink (2016).","category":"page"},{"location":"basics/#Standard-Frank-Wolfe-(FW)","page":"How does it work?","title":"Standard Frank-Wolfe (FW)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the frank_wolfe function.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"See Jaggi (2013) for an overview.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"This algorithm works both for convex and non-convex functions (use step size rule FrankWolfe.Nonconvex() in the second case).","category":"page"},{"location":"basics/#Away-step-Frank-Wolfe-(AFW)","page":"How does it work?","title":"Away-step Frank-Wolfe (AFW)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the away_frank_wolfe function.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"See Lacoste-Julien, Jaggi (2015) for an overview.","category":"page"},{"location":"basics/#Stochastic-Frank-Wolfe-(SFW)","page":"How does it work?","title":"Stochastic Frank-Wolfe (SFW)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the FrankWolfe.stochastic_frank_wolfe function.","category":"page"},{"location":"basics/#Blended-Conditional-Gradients-(BCG)","page":"How does it work?","title":"Blended Conditional Gradients (BCG)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the blended_conditional_gradient function, with a built-in stability feature that temporarily increases accuracy.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"See Braun, Pokutta, Tu, Wright (2018).","category":"page"},{"location":"basics/#Pairwise-Frank-Wolfe-(PFW)","page":"How does it work?","title":"Pairwise Frank-Wolfe (PFW)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the pairwise_frank_wolfe function. See Lacoste-Julien, Jaggi (2015) for an overview.","category":"page"},{"location":"basics/#Blended-Pairwise-Conditional-Gradients-(BPCG)","page":"How does it work?","title":"Blended Pairwise Conditional Gradients (BPCG)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the FrankWolfe.blended_pairwise_conditional_gradient function, with a minor modification to improve sparsity.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"See Tsuji, Tanaka, Pokutta (2021)","category":"page"},{"location":"basics/#Corrective-Frank-Wolfe-(CFW)","page":"How does it work?","title":"Corrective Frank-Wolfe (CFW)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the FrankWolfe.corrective_frank_wolfe function and generalizes multiple Frank-Wolfe algorithms which alternate between FW steps and steps based on the active set (e.g., away step, blended pairwise steps, ...).","category":"page"},{"location":"basics/#Comparison","page":"How does it work?","title":"Comparison","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The following table compares the characteristics of the algorithms presented in the package:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Algorithm Progress/Iteration Time/Iteration Sparsity Numerical Stability Active Set Lazifiable\nFW Low Low Low High No Yes\nAFW Medium Medium-High Medium Medium-High Yes Yes\nB(P)CG High Medium-High High Medium Yes By design\nSFW Low Low Low High No No","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"While the standard Frank-Wolfe algorithm can only move towards extreme points of the compact convex set mathcalC, Away-step Frank-Wolfe can move away from them. The following figure from our paper illustrates this behaviour:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"(Image: FW vs AFW).","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Both algorithms minimize a quadratic function (whose contour lines are depicted) over a simple polytope (the black square). When the minimizer lies on a face, the standard Frank-Wolfe algorithm zig-zags towards the solution, while its Away-step variant converges more quickly.","category":"page"},{"location":"basics/#Block-Coordinate-Frank-Wolfe-(BCFW)","page":"How does it work?","title":"Block-Coordinate Frank-Wolfe (BCFW)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the FrankWolfe.block_coordinate_frank_wolfe function.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"See Lacoste-Julien, Jaggi, Schmidt, Pletscher (2013) and Beck, Pauwels, Sabach (2015) for more details about different variants of Block-Coordinate Frank-Wolfe.","category":"page"},{"location":"basics/#Alternating-Linear-Minimization-(ALM)","page":"How does it work?","title":"Alternating Linear Minimization (ALM)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"It is implemented in the FrankWolfe.alternating_linear_minimization function.","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_01_mathopt_lmo/#Comparison-with-MathOptInterface-on-a-Probability-Simplex","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"","category":"section"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"In this example, we project a random point onto a probability simplex with the Frank-Wolfe algorithm using either the specialized LMO defined in the package or a generic LP formulation using MathOptInterface.jl (MOI) and GLPK as underlying LP solver. It can be found as Example 4.4 in the paper.","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"using FrankWolfe\n\nusing LinearAlgebra\nusing LaTeXStrings\n\nusing Plots\n\nusing JuMP\nconst MOI = JuMP.MOI\n\nimport GLPK\n\nn = Int(1e3)\nk = 10000\n\nxpi = rand(n);\ntotal = sum(xpi);\nconst xp = xpi ./ total;\n\nf(x) = norm(x - xp)^2\nfunction grad!(storage, x)\n    @. storage = 2 * (x - xp)\n    return nothing\nend\n\nlmo_radius = 2.5\nlmo = FrankWolfe.FrankWolfe.ProbabilitySimplexOracle(lmo_radius)\n\nx00 = FrankWolfe.compute_extreme_point(lmo, zeros(n))\ngradient = collect(x00)\n\nx_lmo, v, primal, dual_gap, trajectory_lmo = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    collect(copy(x00)),\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=false,\n    trajectory=true,\n);\nnothing #hide","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"Create a MathOptInterface Optimizer and build the same linear constraints:","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"o = GLPK.Optimizer()\nx = MOI.add_variables(o, n)\n\nfor xi in x\n    MOI.add_constraint(o, xi, MOI.GreaterThan(0.0))\nend\n\nMOI.add_constraint(\n    o,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(1.0, x), 0.0),\n    MOI.EqualTo(lmo_radius),\n)\n\nlmo_moi = FrankWolfe.MathOptLMO(o)\n\nx, v, primal, dual_gap, trajectory_moi = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo_moi,\n    collect(copy(x00)),\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=false,\n    trajectory=true,\n);\nnothing #hide","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"Alternatively, we can use one of the modelling interfaces based on MOI to formulate the LP. The following example builds the same set of constraints using JuMP:","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"m = JuMP.Model(GLPK.Optimizer)\n@variable(m, y[1:n] ≥ 0)\n\n@constraint(m, sum(y) == lmo_radius)\n\nlmo_jump = FrankWolfe.MathOptLMO(m.moi_backend)\n\nx, v, primal, dual_gap, trajectory_jump = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo_jump,\n    collect(copy(x00)),\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=false,\n    trajectory=true,\n);\n\nx_lmo, v, primal, dual_gap, trajectory_lmo_blas = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x00,\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.OutplaceEmphasis(),\n    verbose=false,\n    trajectory=true,\n);\n\nx, v, primal, dual_gap, trajectory_jump_blas = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo_jump,\n    x00,\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.OutplaceEmphasis(),\n    verbose=false,\n    trajectory=true,\n);\nnothing #hide","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"We can now plot the results","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"iteration_list = [[x[1] + 1 for x in trajectory_lmo], [x[1] + 1 for x in trajectory_moi]]\ntime_list = [[x[5] for x in trajectory_lmo], [x[5] for x in trajectory_moi]]\nprimal_gap_list = [[x[2] for x in trajectory_lmo], [x[2] for x in trajectory_moi]]\ndual_gap_list = [[x[4] for x in trajectory_lmo], [x[4] for x in trajectory_moi]]\n\nlabel = [L\"\\textrm{Closed-form LMO}\", L\"\\textrm{MOI LMO}\"]\n\nplot_results(\n    [primal_gap_list, primal_gap_list, dual_gap_list, dual_gap_list],\n    [iteration_list, time_list, iteration_list, time_list],\n    label,\n    [\"\", \"\", L\"\\textrm{Iteration}\", L\"\\textrm{Time}\"],\n    [L\"\\textrm{Primal Gap}\", \"\", L\"\\textrm{Dual Gap}\", \"\"],\n    xscalelog=[:log, :identity, :log, :identity],\n    yscalelog=[:log, :log, :log, :log],\n    legend_position=[:bottomleft, nothing, nothing, nothing],\n)","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"","category":"page"},{"location":"examples/docs_01_mathopt_lmo/","page":"Comparison with MathOptInterface on a Probability Simplex","title":"Comparison with MathOptInterface on a Probability Simplex","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/2_lmo/#Linear-Minimization-Oracles","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"","category":"section"},{"location":"reference/2_lmo/","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"The Linear Minimization Oracle (LMO) is a key component called at each iteration of the FW algorithm. Given din mathcalX, it returns a vertex of the feasible set:","category":"page"},{"location":"reference/2_lmo/","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"vin argmin_xin mathcalC langle dx rangle","category":"page"},{"location":"reference/2_lmo/","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"See Combettes, Pokutta 2021 for references on most LMOs implemented in the package and their comparison with projection operators.","category":"page"},{"location":"reference/2_lmo/#Interface-and-wrappers","page":"Linear Minimization Oracles","title":"Interface and wrappers","text":"","category":"section"},{"location":"reference/2_lmo/#FrankWolfe.LinearMinimizationOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.LinearMinimizationOracle","text":"LinearMinimizationOracle\n\nSupertype for linear minimization oracles.\n\nAll LMOs must implement compute_extreme_point(lmo::LMO, direction) and return a vector v of the appropriate type.\n\nSee also: compute_extreme_point.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"All of them are subtypes of FrankWolfe.LinearMinimizationOracle and implement the following method:","category":"page"},{"location":"reference/2_lmo/#FrankWolfe.compute_extreme_point","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_extreme_point","text":"compute_extreme_point(lmo::LinearMinimizationOracle, direction; kwargs...)\n\nComputes the point argmin_{v ∈ C} v ⋅ direction with C the set represented by the LMO. Most LMOs feature v as a keyword argument that allows for an in-place computation whenever v is dense. All LMOs should accept keyword arguments that they can ignore.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_lmo/","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"We also provide some meta-LMOs wrapping another one with extended behavior:","category":"page"},{"location":"reference/2_lmo/#FrankWolfe.CachedLinearMinimizationOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.CachedLinearMinimizationOracle","text":"CachedLinearMinimizationOracle{LMO}\n\nOracle wrapping another one of type lmo. Subtypes of CachedLinearMinimizationOracle contain a cache of previous solutions.\n\nBy convention, the inner oracle is named inner. Cached optimizers are expected to implement Base.empty! and Base.length.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.ProductLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.ProductLMO","text":"ProductLMO(lmos)\n\nLinear minimization oracle over the Cartesian product of multiple LMOs.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.SingleLastCachedLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.SingleLastCachedLMO","text":"SingleLastCachedLMO{LMO, VT}\n\nCaches only the last result from an LMO and stores it in last_vertex. Vertices of LMO have to be of type VT if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.MultiCacheLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.MultiCacheLMO","text":"MultiCacheLMO{N, LMO, A}\n\nCache for a LMO storing up to N vertices in the cache, removed in FIFO style. oldest_idx keeps track of the oldest index in the tuple, i.e. to replace next. VT, if provided, must be the type of vertices returned by LMO\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.VectorCacheLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.VectorCacheLMO","text":"VectorCacheLMO{LMO, VT}\n\nCache for a LMO storing an unbounded number of vertices of type VT in the cache. VT, if provided, must be the type of vertices returned by LMO\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#Norm-balls","page":"Linear Minimization Oracles","title":"Norm balls","text":"","category":"section"},{"location":"reference/2_lmo/#FrankWolfe.EllipsoidLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.EllipsoidLMO","text":"EllipsoidLMO(A, c, r)\n\nLinear minimization over an ellipsoid centered at c of radius r:\n\nx: (x - c)^T A (x - c) ≤ r\n\nThe LMO stores the factorization F of A that is used to solve linear systems A⁻¹ x. The result of the linear system solve is stored in buffer. The ellipsoid is assumed to be full-dimensional -> A is positive definite.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.KNormBallLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.KNormBallLMO","text":"KNormBallLMO{T}(K::Int, right_hand_side::T)\n\nLMO with feasible set being the K-norm ball in the sense of 2010.07243, i.e., the convex hull over the union of an L1-ball with radius τ and an L∞-ball with radius τ/K:\n\nC_{K,τ} = conv { B_1(τ) ∪ B_∞(τ / K) }\n\nwith τ the right_hand_side parameter. The K-norm is defined as the sum of the largest K absolute entries in a vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.LpNormLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.LpNormLMO","text":"LpNormLMO{T, p}(right_hand_side)\n\nLMO with feasible set being an L-p norm ball:\n\nC = {x ∈ R^n, norm(x, p) ≤ right_hand_side}\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.OrderWeightNormLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.OrderWeightNormLMO","text":"OrderWeightNormLMO(weights,radius)\n\nLMO with feasible set being the atomic ordered weighted l1 norm: https://arxiv.org/pdf/1409.4271\n\nC = {x ∈ R^n, Ω_w(x) ≤ R} \n\nThe weights are assumed to be positive.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#Simplex","page":"Linear Minimization Oracles","title":"Simplex","text":"","category":"section"},{"location":"reference/2_lmo/#FrankWolfe.HyperSimplexOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.HyperSimplexOracle","text":"HyperSimplexOracle(radius)\n\nRepresents the scaled hypersimplex of radius τ, the convex hull of vectors v such that:\n\nv_i ∈ {0, τ}\n||v||_0 = k\n\nEquivalently, this is the convex hull of the vertices of the K-sparse polytope lying in the nonnegative orthant.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.ProbabilitySimplexOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.ProbabilitySimplexOracle","text":"ProbabilitySimplexOracle(right_side)\n\nRepresents the scaled probability simplex:\n\nC = {x ∈ R^n_+, ∑x = right_side}\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.UnitHyperSimplexOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.UnitHyperSimplexOracle","text":"UnitHyperSimplexOracle(radius)\n\nRepresents the scaled unit hypersimplex of radius τ, the convex hull of vectors v such that:\n\nv_i ∈ {0, τ}\n||v||_0 ≤ k\n\nEquivalently, this is the intersection of the K-sparse polytope and the nonnegative orthant.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.UnitSimplexOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.UnitSimplexOracle","text":"UnitSimplexOracle(right_side)\n\nRepresents the scaled unit simplex:\n\nC = {x ∈ R^n_+, ∑x ≤ right_side}\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_dual_solution","text":"Dual costs for a given primal solution to form a primal dual pair for scaled probability simplex. Returns two vectors. The first one is the dual costs associated with the constraints and the second is the reduced costs for the variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_dual_solution","text":"Dual costs for a given primal solution to form a primal dual pair for scaled unit simplex. Returns two vectors. The first one is the dual costs associated with the constraints and the second is the reduced costs for the variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_extreme_point","text":"LMO for scaled probability simplex. Returns a vector with one active value equal to RHS in the most improving (or least degrading) direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_extreme_point","text":"LMO for scaled unit simplex: ∑ x_i ≤ τ Returns either vector of zeros or vector with one active value equal to RHS if there exists an improving direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#Polytope","page":"Linear Minimization Oracles","title":"Polytope","text":"","category":"section"},{"location":"reference/2_lmo/#FrankWolfe.BirkhoffPolytopeLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.BirkhoffPolytopeLMO","text":"BirkhoffPolytopeLMO\n\nThe Birkhoff polytope encodes doubly stochastic matrices. Its extreme vertices are all permutation matrices of side-dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.ConvexHullOracle","page":"Linear Minimization Oracles","title":"FrankWolfe.ConvexHullOracle","text":"ConvexHullOracle{AT,VT}\n\nConvex hull of a finite number of vertices of type AT, stored in a vector of type VT.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.KSparseLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.KSparseLMO","text":"KSparseLMO{T}(K::Int, right_hand_side::T)\n\nLMO for the K-sparse polytope:\n\nC = B_1(τK) ∩ B_∞(τ)\n\nwith τ the right_hand_side parameter. The LMO results in a vector with the K largest absolute values of direction, taking values -τ sign(x_i).\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.ScaledBoundL1NormBall","page":"Linear Minimization Oracles","title":"FrankWolfe.ScaledBoundL1NormBall","text":"ScaledBoundL1NormBall(lower_bounds, upper_bounds)\n\nPolytope similar to a L1-ball with shifted bounds. It is the convex hull of two scaled and shifted unit vectors for each axis (shifted to the center of the polytope, i.e., the elementwise midpoint of the bounds). Lower and upper bounds are passed on as abstract vectors, possibly of different types. For the standard L1-ball, all lower and upper bounds would be -1 and 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.ScaledBoundLInfNormBall","page":"Linear Minimization Oracles","title":"FrankWolfe.ScaledBoundLInfNormBall","text":"ScaledBoundLInfNormBall(lower_bounds, upper_bounds)\n\nPolytope similar to a L-inf-ball with shifted bounds or general box constraints. Lower- and upper-bounds are passed on as abstract vectors, possibly of different types. For the standard L-inf ball, all lower- and upper-bounds would be -1 and 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.ZeroOneHypercube","page":"Linear Minimization Oracles","title":"FrankWolfe.ZeroOneHypercube","text":"ZeroOneHypercube\n\n{0,1} hypercube polytope.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#Spectral-sets","page":"Linear Minimization Oracles","title":"Spectral sets","text":"","category":"section"},{"location":"reference/2_lmo/#FrankWolfe.FantopeLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.FantopeLMO","text":"FantopeLMO(k::Int)\n\nSpectrahedron defined on square symmetric matrices as: F_k = {X : 0 ≼ X ≼ I_n, tr(X) = k} or equivalently as: F_k = conv{VVᵀ, VᵀV = I_k}\n\nSource: V.Q. Vu, J. Cho, J. Lei, K. Rohe Dattorro, Convex optimization & euclidean distance geometry, 2.3.2.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.NuclearNormLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.NuclearNormLMO","text":"NuclearNormLMO{T}(radius)\n\nLMO over matrices that have a nuclear norm less than radius. The LMO returns the best rank-one approximation matrix with singular value radius, computed with Arpack.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.SpectraplexLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.SpectraplexLMO","text":"SpectraplexLMO{T,M}(radius::T,gradient_container::M,ensure_symmetry::Bool=true)\n\nFeasible set\n\n{X ∈ 𝕊_n^+, trace(X) == radius}\n\ngradient_container is used to store the symmetrized negative direction. ensure_symmetry indicates whether the linear function is made symmetric before computing the eigenvector.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.UnitSpectrahedronLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.UnitSpectrahedronLMO","text":"UnitSpectrahedronLMO{T,M}(radius::T, gradient_container::M)\n\nFeasible set of PSD matrices with bounded trace:\n\n{X ∈ 𝕊_n^+, trace(X) ≤ radius}\n\ngradient_container is used to store the symmetrized negative direction. ensure_symmetry indicates whether the linear function is made symmetric before computing the eigenvector.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#MathOptInterface","page":"Linear Minimization Oracles","title":"MathOptInterface","text":"","category":"section"},{"location":"reference/2_lmo/#FrankWolfe.MathOptLMO","page":"Linear Minimization Oracles","title":"FrankWolfe.MathOptLMO","text":"MathOptLMO{OT <: MOI.AbstractOptimizer} <: LinearMinimizationOracle\n\nLinear minimization oracle with feasible space defined through a MathOptInterface.Optimizer. The oracle call sets the direction and reruns the optimizer.\n\nThe direction vector has to be set in the same order of variables as the MOI.ListOfVariableIndices() getter.\n\nThe Boolean use_modify determines if the objective incompute_extreme_point is updated with MOI.modify(o, ::MOI.ObjectiveFunction, ::MOI.ScalarCoefficientChange) or with MOI.set(o, ::MOI.ObjectiveFunction, f). use_modify = true decreases the runtime and memory allocation for models created as an optimizer object and defined directly with MathOptInterface. use_modify = false should be used for CachingOptimizers.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_lmo/#FrankWolfe.compute_inface_extreme_point-Union{Tuple{OT}, Tuple{FrankWolfe.MathOptLMO{OT}, Any, Any}} where OT","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_inface_extreme_point","text":"Copy and modify the constriants if necesssary for computing in-face vertex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#FrankWolfe.compute_inface_extreme_point_subroutine-Union{Tuple{S}, Tuple{F}, Tuple{OT}, Tuple{FrankWolfe.MathOptLMO{OT}, Type{F}, Type{S}, Any}} where {OT, F, S}","page":"Linear Minimization Oracles","title":"FrankWolfe.compute_inface_extreme_point_subroutine","text":"function barrier for performance\n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#FrankWolfe.convert_mathopt","page":"Linear Minimization Oracles","title":"FrankWolfe.convert_mathopt","text":"convert_mathopt(lmo::LMO, optimizer::OT; kwargs...) -> MathOptLMO{OT}\n\nConverts the given LMO to its equivalent MathOptInterface representation using optimizer. Must be implemented by LMOs.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_lmo/#FrankWolfe.dicg_maximum_step-Union{Tuple{OT}, Tuple{FrankWolfe.MathOptLMO{OT}, Any, Any}} where OT","page":"Linear Minimization Oracles","title":"FrankWolfe.dicg_maximum_step","text":"Fast way to compute gammamax. Check every constraint and compute the corresponding gammaupper_bound. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_lmo/#Index","page":"Linear Minimization Oracles","title":"Index","text":"","category":"section"},{"location":"reference/2_lmo/","page":"Linear Minimization Oracles","title":"Linear Minimization Oracles","text":"Pages = [\"1_lmo.md\"]","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_00_fw_visualized/#Visualization-of-Frank-Wolfe-running-on-a-2-dimensional-polytope","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"","category":"section"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"This example provides an intuitive view of the Frank-Wolfe algorithm by running it on a polyhedral set with a quadratic function. The Linear Minimization Oracle (LMO) corresponds to a call to a generic simplex solver from MathOptInterface.jl (MOI).","category":"page"},{"location":"examples/docs_00_fw_visualized/#Import-and-setup","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Import and setup","text":"","category":"section"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"We first import the necessary packages, including Polyhedra to visualize the feasible set.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"using LinearAlgebra\nusing FrankWolfe\n\nimport MathOptInterface\nconst MOI = MathOptInterface\nusing GLPK\n\nusing Polyhedra\nusing Plots","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"We can then define the objective function, here the squared distance to a point in the place, and its in-place gradient.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"n = 2\ny = [3.2, 0.5]\n\nfunction f(x)\n    return 1 / 2 * norm(x - y)^2\nend\nfunction grad!(storage, x)\n    @. storage = x - y\nend","category":"page"},{"location":"examples/docs_00_fw_visualized/#Custom-callback","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Custom callback","text":"","category":"section"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"FrankWolfe.jl lets users define custom callbacks to record information about each iteration. In that case, the callback will copy the current iterate x, the current vertex v, and the current step size gamma to an array thanks to a closure. We then declare the array and the callback over this array. Each iteration will then push to this array.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"function build_callback(trajectory_arr)\n    return function callback(state, args...)\n        return push!(trajectory_arr, (copy(state.x), copy(state.v), state.gamma))\n    end\nend\n\niterates_information_vector = []\ncallback = build_callback(iterates_information_vector)","category":"page"},{"location":"examples/docs_00_fw_visualized/#Creating-the-Linear-Minimization-Oracle","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Creating the Linear Minimization Oracle","text":"","category":"section"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"The LMO is defined as a call to a linear optimization solver, each iteration resets the objective and calls the solver. The linear constraints must be defined only once at the beginning and remain identical along iterations. We use here MathOptInterface directly but the constraints could also be defined with JuMP or Convex.jl.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"o = GLPK.Optimizer()\nx = MOI.add_variables(o, n)\n\n# −x + y ≤ 2\nc1 = MOI.add_constraint(o, -1.0x[1] + x[2], MOI.LessThan(2.0))\n\n# x + 2 y ≤ 4\nc2 = MOI.add_constraint(o, x[1] + 2.0x[2], MOI.LessThan(4.0))\n\n# −2 x − y ≤ 1\nc3 = MOI.add_constraint(o, -2.0x[1] - x[2], MOI.LessThan(1.0))\n\n# x − 2 y ≤ 2\nc4 = MOI.add_constraint(o, x[1] - 2.0x[2], MOI.LessThan(2.0))\n\n# x ≤ 2\nc5 = MOI.add_constraint(o, x[1] + 0.0x[2], MOI.LessThan(2.0))","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"The LMO is then built by wrapping the current MOI optimizer","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"lmo_moi = FrankWolfe.MathOptLMO(o)","category":"page"},{"location":"examples/docs_00_fw_visualized/#Calling-Frank-Wolfe","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Calling Frank-Wolfe","text":"","category":"section"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"We can now compute an initial starting point from any direction and call the Frank-Wolfe algorithm. Note that we copy x0 before passing it to the algorithm because it is modified in-place by frank_wolfe.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"x0 = FrankWolfe.compute_extreme_point(lmo_moi, zeros(n))\n\nxfinal, vfinal, primal_value, dual_gap, traj_data = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo_moi,\n    copy(x0),\n    line_search=FrankWolfe.Adaptive(),\n    max_iteration=10,\n    epsilon=1e-8,\n    callback=callback,\n    verbose=true,\n    print_iter=1,\n)","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"We now collect the iterates and vertices across iterations.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"iterates = Vector{Vector{Float64}}()\npush!(iterates, x0)\nvertices = Vector{Vector{Float64}}()\nfor s in iterates_information_vector\n    push!(iterates, s[1])\n    push!(vertices, s[2])\nend","category":"page"},{"location":"examples/docs_00_fw_visualized/#Plotting-the-algorithm-run","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Plotting the algorithm run","text":"","category":"section"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"We define another method for f adapted to plot its contours.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"function f(x1, x2)\n    x = [x1, x2]\n    return f(x)\nend\n\nxlist = collect(range(-1, 3, step=0.2))\nylist = collect(range(-1, 3, step=0.2))\n\nX = repeat(reshape(xlist, 1, :), length(ylist), 1)\nY = repeat(ylist, 1, length(xlist))","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"The feasible space is represented using Polyhedra.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"h =\n    HalfSpace([-1, 1], 2) ∩ HalfSpace([1, 2], 4) ∩ HalfSpace([-2, -1], 1) ∩ HalfSpace([1, -2], 2) ∩\n    HalfSpace([1, 0], 2)\n\np = polyhedron(h)\n\np1 = contour(xlist, ylist, f, fill=true, line_smoothing=0.85)\nplot(p1, opacity=0.5)\nplot!(\n    p,\n    ratio=:equal,\n    opacity=0.5,\n    label=\"feasible region\",\n    framestyle=:zerolines,\n    legend=true,\n    color=:blue,\n);\nnothing #hide","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"Finally, we add all iterates and vertices to the plot.","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"colors = [\"gold\", \"purple\", \"darkorange2\", \"firebrick3\"]\niterates = unique!(iterates)\nfor i in 1:3\n    scatter!(\n        [iterates[i][1]],\n        [iterates[i][2]],\n        label=string(\"x_\", i - 1),\n        markersize=6,\n        color=colors[i],\n    )\nend\nscatter!(\n    [last(iterates)[1]],\n    [last(iterates)[2]],\n    label=string(\"x_\", length(iterates) - 1),\n    markersize=6,\n    color=last(colors),\n)","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"plot chosen vertices","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"scatter!([vertices[1][1]], [vertices[1][2]], m=:diamond, markersize=6, color=colors[1], label=\"v_1\")\nscatter!(\n    [vertices[2][1]],\n    [vertices[2][2]],\n    m=:diamond,\n    markersize=6,\n    color=colors[2],\n    label=\"v_2\",\n    legend=:outerleft,\n    colorbar=true,\n)","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"","category":"page"},{"location":"examples/docs_00_fw_visualized/","page":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","title":"Visualization of Frank-Wolfe running on a 2-dimensional polytope","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_04_rational_opt/#Exact-Optimization-with-Rational-Arithmetic","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"","category":"section"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"This example can be found in section 4.3 in the paper. The package allows for exact optimization with rational arithmetic. For this, it suffices to set up the LMO to be rational and choose an appropriate step-size rule as detailed below. For the LMOs included in the package, this simply means initializing the radius with a rational-compatible element type, e.g., 1, rather than a floating-point number, e.g., 1.0. Given that numerators and denominators can become quite large in rational arithmetic, it is strongly advised to base the used rationals on extended-precision integer types such as BigInt, i.e., we use Rational{BigInt}.","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"The second requirement ensuring that the computation runs in rational arithmetic is a rational-compatible step-size rule. The most basic step-size rule compatible with rational optimization is the agnostic step-size rule with gamma_t = 2(2 + t). With this step-size rule, the gradient does not even need to be rational as long as the atom computed by the LMO is of a rational type. Assuming these requirements are met, all iterates and the computed solution will then be rational.","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"using FrankWolfe\nusing LinearAlgebra\n\nn = 100\nk = n\n\nx = fill(big(1) // 100, n)\n\nf(x) = dot(x, x)\nfunction grad!(storage, x)\n    @. storage = 2 * x\nend","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"pick feasible region radius needs to be integer or rational","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"lmo = FrankWolfe.ProbabilitySimplexOracle{Rational{BigInt}}(1)","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"compute some initial vertex","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"x0 = FrankWolfe.compute_extreme_point(lmo, zeros(n));\n\nx, v, primal, dual_gap, trajectory = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=k,\n    line_search=FrankWolfe.Agnostic(),\n    print_iter=k / 10,\n    verbose=true,\n    memory_mode=FrankWolfe.OutplaceEmphasis(),\n);\n\nprintln(\"\\nOutput type of solution: \", eltype(x))","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"Another possible step-size rule is rationalshortstep which computes the step size by minimizing the smoothness inequality as gamma_t=fraclangle nabla f(x_t)x_t-v_trangle2Lx_t-v_t^2. However, as this step size depends on an upper bound on the Lipschitz constant L as well as the inner product with the gradient nabla f(x_t), both have to be of a rational type.","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"@time x, v, primal, dual_gap, trajectory = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2 // 1),\n    print_iter=k / 10,\n    verbose=true,\n    memory_mode=FrankWolfe.OutplaceEmphasis(),\n);\nnothing #hide","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"Note: at the last step, we exactly close the gap, finding the solution 1//n * ones(n)","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"","category":"page"},{"location":"examples/docs_04_rational_opt/","page":"Exact Optimization with Rational Arithmetic","title":"Exact Optimization with Rational Arithmetic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/5_gradient_descent/#Adaptive-Proximal-Gradient-Descent-Methods","page":"Adaptive Proximal Gradient Descent Methods","title":"Adaptive Proximal Gradient Descent Methods","text":"","category":"section"},{"location":"reference/5_gradient_descent/","page":"Adaptive Proximal Gradient Descent Methods","title":"Adaptive Proximal Gradient Descent Methods","text":"This package implements several variants of adaptive proximal gradient descent methods. Their primary use is internal to FrankWolfe.jl, specifically for the Blended Conditional Gradients algorithm, but they can also be used as standalone algorithms.","category":"page"},{"location":"reference/5_gradient_descent/#FrankWolfe.adaptive_gradient_descent-Tuple{Any, Any, Any}","page":"Adaptive Proximal Gradient Descent Methods","title":"FrankWolfe.adaptive_gradient_descent","text":"adaptive_gradient_descent(f, grad!, x0; kwargs...)\n\nAdaptive gradient descent algorithm that automatically adjusts the step size based on local Lipschitz estimates.\n\nArguments\n\nf: Objective function\ngrad!: In-place gradient function\nx0: Initial point\nstep0: Initial step size (default: 1.0)\nmax_iteration: Maximum number of iterations (default: 10000)\nepsilon: Tolerance for stopping criterion (default: 1e-7)\ncallback: Optional callback function (default: nothing)\nverbose: Whether to print progress (default: false)\nmemory_mode: Memory emphasis mode (default: InplaceEmphasis())\n\nReturns\n\nTuple containing:\n\nFinal iterate\nFinal objective value\nVector of states from callback\n\n\n\n\n\n","category":"method"},{"location":"reference/5_gradient_descent/#FrankWolfe.adaptive_gradient_descent2-Tuple{Any, Any, Any}","page":"Adaptive Proximal Gradient Descent Methods","title":"FrankWolfe.adaptive_gradient_descent2","text":"adaptive_gradient_descent2(f, grad!, x0; kwargs...)\n\nSecond variant of adaptive gradient descent with modified step size adaptation.\n\nTakes the same arguments as adaptive_gradient_descent.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_gradient_descent/#FrankWolfe.proximal_adaptive_gradient_descent","page":"Adaptive Proximal Gradient Descent Methods","title":"FrankWolfe.proximal_adaptive_gradient_descent","text":"proximal_adaptive_gradient_descent(f, grad!, prox, x0; kwargs...)\n\nProximal variant of adaptive gradient descent that includes a proximal operator in the update step.\n\nArguments\n\nf: Objective function\ngrad!: In-place gradient function\nprox: Proximal operator (default: identity)\nx0: Initial point\nstep0: Initial step size (default: 1.0)\nmax_iteration: Maximum number of iterations (default: 10000)\nepsilon: Tolerance for stopping criterion (default: 1e-7)\ncallback: Optional callback function (default: nothing)\nverbose: Whether to print progress (default: false)\nmemory_mode: Memory emphasis mode (default: InplaceEmphasis())\n\nReturns\n\nTuple containing:\n\nFinal iterate\nFinal objective value\nVector of states from callback\n\n\n\n\n\n","category":"function"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide\nusing FrankWolfe\nusing LinearAlgebra\nusing LaTeXStrings\nusing Plots","category":"page"},{"location":"examples/docs_07_shifted_norm_polytopes/#FrankWolfe-for-scaled,-shifted-\\ell1-and-\\ell{\\infty}-norm-balls","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"","category":"section"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"In this example, we run the vanilla FrankWolfe algorithm on a scaled and shifted ell^1 and ell^infty norm ball, using the ScaledBoundL1NormBall and ScaledBoundLInfNormBall LMOs. We shift both onto the point (10) and then scale them by a factor of 2 along the x-axis. We project the point (21) onto the polytopes.","category":"page"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"n = 2\n\nk = 1000\n\nxp = [2.0, 1.0]\n\nf(x) = norm(x - xp)^2\n\nfunction grad!(storage, x)\n    @. storage = 2 * (x - xp)\n    return nothing\nend\n\nlower = [-1.0, -1.0]\nupper = [3.0, 1.0]\n\nl1 = FrankWolfe.ScaledBoundL1NormBall(lower, upper)\n\nlinf = FrankWolfe.ScaledBoundLInfNormBall(lower, upper)\n\nx1 = FrankWolfe.compute_extreme_point(l1, zeros(n))\ngradient = collect(x1)\n\nx_l1, v_1, primal_1, dual_gap_1, trajectory_1 = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    l1,\n    collect(copy(x1)),\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=50,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=true,\n    trajectory=true,\n);\n\nprintln(\"\\nFinal solution: \", x_l1)\n\nx2 = FrankWolfe.compute_extreme_point(linf, zeros(n))\ngradient = collect(x2)\n\nx_linf, v_2, primal_2, dual_gap_2, trajectory_2 = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    linf,\n    collect(copy(x2)),\n    max_iteration=k,\n    line_search=FrankWolfe.Shortstep(2.0),\n    print_iter=50,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=true,\n    trajectory=true,\n);\n\nprintln(\"\\nFinal solution: \", x_linf)","category":"page"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"We plot the polytopes alongside the solutions from above:","category":"page"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"xcoord1 = [1, 3, 1, -1, 1]\nycoord1 = [-1, 0, 1, 0, -1]\n\nxcoord2 = [3, 3, -1, -1, 3]\nycoord2 = [-1, 1, 1, -1, -1]\n\nplot(\n    xcoord1,\n    ycoord1,\n    title=\"Visualization of scaled shifted norm balls\",\n    lw=2,\n    label=L\"\\ell^1 \\textrm{ norm}\",\n)\nplot!(xcoord2, ycoord2, lw=2, label=L\"\\ell^{\\infty} \\textrm{ norm}\")\nplot!(\n    [x_l1[1]],\n    [x_l1[2]],\n    seriestype=:scatter,\n    lw=5,\n    color=\"blue\",\n    label=L\"\\ell^1 \\textrm{ solution}\",\n)\nplot!(\n    [x_linf[1]],\n    [x_linf[2]],\n    seriestype=:scatter,\n    lw=5,\n    color=\"orange\",\n    label=L\"\\ell^{\\infty} \\textrm{ solution}\",\n    legend=:bottomleft,\n)","category":"page"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"","category":"page"},{"location":"examples/docs_07_shifted_norm_polytopes/","page":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","title":"FrankWolfe for scaled, shifted ell^1 and ell^infty norm balls","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_06_spectrahedron/#Spectrahedron","page":"Spectrahedron","title":"Spectrahedron","text":"","category":"section"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"This example shows an optimization problem over the spectraplex:","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"S = X in mathbbS_+^n Tr(X) = 1","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"with mathbbS_+^n the set of positive semidefinite matrices. Linear optimization with symmetric objective D over the spetraplex consists in computing the leading eigenvector of D.","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"The package also exposes UnitSpectrahedronLMO which corresponds to the feasible set:","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"S_u = X in mathbbS_+^n Tr(X) leq 1","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"using FrankWolfe\nusing LinearAlgebra\nusing Random\nusing SparseArrays","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"The objective function will be the symmetric squared distance to a set of known or observed entries Y_ij of the matrix.","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"f(X) = sum_(ij) in L 12 (X_ij - Y_ij)^2","category":"page"},{"location":"examples/docs_06_spectrahedron/#Setting-up-the-input-data,-objective,-and-gradient","page":"Spectrahedron","title":"Setting up the input data, objective, and gradient","text":"","category":"section"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"Dimension, number of iterations and number of known entries:","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"n = 1500\nk = 5000\nn_entries = 1000\n\nRandom.seed!(41)\n\nconst entry_indices = unique!([minmax(rand(1:n, 2)...) for _ in 1:n_entries])\nconst entry_values = randn(length(entry_indices))\n\nfunction f(X)\n    r = zero(eltype(X))\n    for (idx, (i, j)) in enumerate(entry_indices)\n        r += 1 / 2 * (X[i, j] - entry_values[idx])^2\n        r += 1 / 2 * (X[j, i] - entry_values[idx])^2\n    end\n    return r / length(entry_values)\nend\n\nfunction grad!(storage, X)\n    storage .= 0\n    for (idx, (i, j)) in enumerate(entry_indices)\n        storage[i, j] += (X[i, j] - entry_values[idx])\n        storage[j, i] += (X[j, i] - entry_values[idx])\n    end\n    return storage ./= length(entry_values)\nend","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"Note that the ensure_symmetry = false argument to SpectraplexLMO. It skips an additional step making the used direction symmetric. It is not necessary when the gradient is a LinearAlgebra.Symmetric (or more rarely a LinearAlgebra.Diagonal or LinearAlgebra.UniformScaling).","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"const lmo = FrankWolfe.SpectraplexLMO(1.0, n, false)\nconst x0 = FrankWolfe.compute_extreme_point(lmo, spzeros(n, n))\n\ntarget_tolerance = 1e-8;\nnothing #hide","category":"page"},{"location":"examples/docs_06_spectrahedron/#Running-standard-and-lazified-Frank-Wolfe","page":"Spectrahedron","title":"Running standard and lazified Frank-Wolfe","text":"","category":"section"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"Xfinal, Vfinal, primal, dual_gap, trajectory = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=k,\n    line_search=FrankWolfe.MonotonicStepSize(),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=true,\n    trajectory=true,\n    epsilon=target_tolerance,\n)\n\nXfinal, Vfinal, primal, dual_gap, trajectory_lazy = FrankWolfe.lazified_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    max_iteration=k,\n    line_search=FrankWolfe.MonotonicStepSize(),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=true,\n    trajectory=true,\n    epsilon=target_tolerance,\n);\nnothing #hide","category":"page"},{"location":"examples/docs_06_spectrahedron/#Plotting-the-resulting-trajectories","page":"Spectrahedron","title":"Plotting the resulting trajectories","text":"","category":"section"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"data = [trajectory, trajectory_lazy]\nlabel = [\"FW\", \"LCG\"]\nplot_trajectories(data, label, xscalelog=true)","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"","category":"page"},{"location":"examples/docs_06_spectrahedron/","page":"Spectrahedron","title":"Spectrahedron","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/4_linesearch/#Line-search-and-step-size-settings","page":"Line search and step size settings","title":"Line search and step size settings","text":"","category":"section"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"The step size dictates how far one traverses along a local descent direction. More specifically, the step size gamma_t is used at each iteration to determine how much the next iterate moves towards the new vertex:","category":"page"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"x_t+1 = x_t - gamma_t (x_t - v_t)","category":"page"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"gamma_t = 1 implies that the next iterate is exactly the vertex, a zero gamma_t implies that the iterate is not moving.","category":"page"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"The following are step size selection rules for Frank Wolfe algorithms. Some methodologies (e.g. FixedStep and Agnostic) depend only on the iteration number and induce series gamma_t that are independent of the problem data, while others (e.g. GoldenSearch and Adaptive) change according to local information about the function; the adaptive methods often require extra function and/or gradient computations. The typical options for convex optimization are Agnostic or Adaptive.","category":"page"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"All step size computation strategies are subtypes of FrankWolfe.LineSearchMethod. The key method they have to implement is FrankWolfe.perform_line_search which is called at every iteration to compute the step size gamma.","category":"page"},{"location":"reference/4_linesearch/#FrankWolfe.LineSearchMethod","page":"Line search and step size settings","title":"FrankWolfe.LineSearchMethod","text":"LineSearchMethod\n\nLine search method to apply once the direction is computed. A LineSearchMethod must implement\n\nperform_line_search(ls::LineSearchMethod, t, f, grad!, gradient, x, d, gamma_max, workspace)\n\nwith d = x - v. It may also implement FrankWolfe.build_linesearch_workspace.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.perform_line_search","page":"Line search and step size settings","title":"FrankWolfe.perform_line_search","text":"perform_line_search(ls::LineSearchMethod, t, f, grad!, gradient, x, d, gamma_max, workspace)\n\nReturns the step size gamma for step size strategy ls.\n\n\n\n\n\n","category":"function"},{"location":"reference/4_linesearch/#FrankWolfe.Adaptive","page":"Line search and step size settings","title":"FrankWolfe.Adaptive","text":"Modified adaptive line search test from:\n\nS. Pokutta \"The Frank-Wolfe algorith: a short introduction\" (2023), preprint, https://arxiv.org/abs/2311.05313\n\nIt replaces the original test implemented in the AdaptiveZerothOrder line search based on:\n\nPedregosa, F., Negiar, G., Askari, A., and Jaggi, M. (2020). \"Linearly convergent Frank–Wolfe with backtracking line-search\", Proceedings of AISTATS.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.AdaptiveZerothOrder","page":"Line search and step size settings","title":"FrankWolfe.AdaptiveZerothOrder","text":"Slight modification of the Adaptive Step Size strategy from Pedregosa, Negiar, Askari, Jaggi (2018)\n\n    f(x_t + gamma_t (x_t - v_t)) - f(x_t) leq - alpha gamma_t langle nabla f(x_t) x_t - v_t rangle + alpha^2  fracgamma_t^2 x_t - v_t^22 M \n\nThe parameter alpha ∈ (0,1] relaxes the original smoothness condition to mitigate issues with nummerical errors. Its default value is 0.5. The Adaptive struct keeps track of the Lipschitz constant estimate L_est. The keyword argument relaxed_smoothness allows testing with an alternative smoothness condition,\n\n    langle nabla f(x_t + gamma_t (x_t - v_t) ) - nabla f(x_t) x_t - v_t rangle leq gamma_t M x_t - v_t^2 \n\nThis condition yields potentially smaller and more stable estimations of the Lipschitz constant while being more computationally expensive due to the additional gradient computation.\n\nIt is also the fallback when the Lipschitz constant estimation fails due to numerical errors. perform_line_search also has a should_upgrade keyword argument on whether there should be a temporary upgrade to BigFloat for extended precision.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.Agnostic","page":"Line search and step size settings","title":"FrankWolfe.Agnostic","text":"Computes step size: l/(l + t) at iteration t, given l > 0.\n\nUsing l > 2 leads to faster convergence rates than l = 2 over strongly and some uniformly convex set.\n\nAccelerated Affine-Invariant Convergence Rates of the Frank-Wolfe Algorithm with Open-Loop Step-Sizes, Wirth, Peña, Pokutta (2023), https://arxiv.org/abs/2310.04096 \n\nSee also the paper that introduced the study of open-loop step-sizes with l > 2:\n\nAcceleration of Frank-Wolfe Algorithms with Open-Loop Step-Sizes, Wirth, Kerdreux, Pokutta, (2023), https://arxiv.org/abs/2205.12838\n\nFixing l = -1, results in the step size gamma_t = (2 + log(t+1)) / (t + 2 + log(t+1))\n\nS. Pokutta \"The Frank-Wolfe algorith: a short introduction\" (2023), https://arxiv.org/abs/2311.05313\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.Backtracking","page":"Line search and step size settings","title":"FrankWolfe.Backtracking","text":"Backtracking(limit_num_steps, tol, tau)\n\nBacktracking line search strategy, see Pedregosa, Negiar, Askari, Jaggi (2018).\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.FixedStep","page":"Line search and step size settings","title":"FrankWolfe.FixedStep","text":"Fixed step size strategy. The step size can still be truncated by the gamma_max argument.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.GeneralizedAgnostic","page":"Line search and step size settings","title":"FrankWolfe.GeneralizedAgnostic","text":"Computes step size: g(t)/(t + g(t)) at iteration t, given g: R_{>= 0} -> R_{>= 0}.\n\nDefaults to the best open-loop step-size gamma_t = (2 + log(t+1)) / (t + 2 + log(t+1))\n\nS. Pokutta \"The Frank-Wolfe algorith: a short introduction\" (2023), https://arxiv.org/abs/2311.05313\n\nThis step-size is as fast as the step-size gammat = 2 / (t + 2) up to polylogarithmic factors. Further, over strongly convex and some uniformly convex sets, it is faster than any traditional step-size gammat = l / (t + l) for any l in N.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.Goldenratio","page":"Line search and step size settings","title":"FrankWolfe.Goldenratio","text":"Goldenratio\n\nSimple golden-ratio based line search Golden Section Search, based on Combettes, Pokutta (2020) code and adapted.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.MonotonicNonConvexStepSize","page":"Line search and step size settings","title":"FrankWolfe.MonotonicNonConvexStepSize","text":"MonotonicNonConvexStepSize{F}\n\nRepresents a monotonic open-loop non-convex step size. Contains a halving factor N increased at each iteration until there is primal progress gamma = 1 / sqrt(t + 1) * 2^(-N).\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.MonotonicStepSize","page":"Line search and step size settings","title":"FrankWolfe.MonotonicStepSize","text":"MonotonicStepSize{F}\n\nRepresents a monotonic open-loop step size. Contains a halving factor N increased at each iteration until there is primal progress gamma = 2 / (t + 2) * 2^(-N).\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.Nonconvex","page":"Line search and step size settings","title":"FrankWolfe.Nonconvex","text":"Computes step size: 1/sqrt(t + 1).\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.Secant","page":"Line search and step size settings","title":"FrankWolfe.Secant","text":"Secant(limit_num_steps, tol, domain_oracle)\n\nSecant line search strategy, which iteratively refines the step size using the secant method. This method is geared towards problems with self-concordant functions (but might require extra structure)  and potentially faster than the backtracking line search. The order of convergence is superlinear with exponent 1.618 (Golden Ratio) but not quite quadratic. Convergence is not guaranteed in general.\n\nArguments\n\ninner_ls::LSM: A fallback line search in case the last gamma in Secant does not satisfy the tolerance. Is only used if safe==true. (default Backtracking)\nsafe::Bool: Flag indicating whether the fallback line search should be used. If false, the best gamma from Secant is used. (default true)  \nlimit_num_steps::Int: Maximum number of iterations for the secant method. (default 40)\ntol::Float64: Tolerance for convergence. (default 1e-8)\ndomain_oracle::Function, returns true if the argument x is in the domain of the objective function f.\n\nReferences\n\nSecant Method\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.Shortstep","page":"Line search and step size settings","title":"FrankWolfe.Shortstep","text":"Computes the 'Short step' step size: dual_gap / (L * norm(x - v)^2), where L is the Lipschitz constant of the gradient, x is the current iterate, and v is the current Frank-Wolfe vertex.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_linesearch/#FrankWolfe.build_linesearch_workspace-Tuple{FrankWolfe.LineSearchMethod, Any, Any}","page":"Line search and step size settings","title":"FrankWolfe.build_linesearch_workspace","text":"build_linesearch_workspace(ls::LS, x, gradient)\n\nOptional method to implement for new line-search methods. Builds a workspace for the line search ls which will be used throughout an algorithm. A workspace may be any variable that will be passed along to perform_line_search, typically to avoid allocating intermediate structures (e.g., gradient evaluated at new points).\n\n\n\n\n\n","category":"method"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"See Pedregosa, Negiar, Askari, Jaggi (2020) for the adaptive step size, Carderera, Besançon, Pokutta (2021) for the monotonic step size.","category":"page"},{"location":"reference/4_linesearch/#Index","page":"Line search and step size settings","title":"Index","text":"","category":"section"},{"location":"reference/4_linesearch/","page":"Line search and step size settings","title":"Line search and step size settings","text":"Pages = [\"4_linesearch.md\"]","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_05_blended_cg/#Blended-Conditional-Gradients","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"","category":"section"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"The FW and AFW algorithms, and their lazy variants share one feature: they attempt to make primal progress over a reduced set of vertices. The AFW algorithm does this through away steps (which do not increase the cardinality of the active set), and the lazy variants do this through the use of previously exploited vertices. A third strategy that one can follow is to explicitly blend Frank-Wolfe steps with gradient descent steps over the convex hull of the active set (note that this can be done without requiring a projection oracle over C, thus making the algorithm projection-free). This results in the Blended Conditional Gradient (BCG) algorithm, which attempts to make as much progress as possible through the convex hull of the current active set S_t until it automatically detects that in order to make further progress it requires additional calls to the LMO.","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"See also Blended Conditional Gradients: the unconditioning of conditional gradients, Braun et al, 2019, https://arxiv.org/abs/1805.07311","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"using FrankWolfe\nusing LinearAlgebra\nusing Random\nusing SparseArrays\n\nn = 1000\nk = 10000\n\nRandom.seed!(41)\n\nmatrix = rand(n, n)\nhessian = transpose(matrix) * matrix\nlinear = rand(n)\nf(x) = dot(linear, x) + 0.5 * transpose(x) * hessian * x\nfunction grad!(storage, x)\n    return storage .= linear + hessian * x\nend\nL = eigmax(hessian)","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"We run over the probability simplex and call the LMO to get an initial feasible point:","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"lmo = FrankWolfe.ProbabilitySimplexOracle(1.0);\nx00 = FrankWolfe.compute_extreme_point(lmo, zeros(n))\n\ntarget_tolerance = 1e-5\n\nx0 = deepcopy(x00)\nx, v, primal, dual_gap, trajectoryBCG_accel_simplex, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    epsilon=target_tolerance,\n    max_iteration=k,\n    line_search=FrankWolfe.Adaptive(L_est=L),\n    print_iter=k / 10,\n    hessian=hessian,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    accelerated=true,\n    verbose=true,\n    trajectory=true,\n    sparsity_control=1.0,\n    weight_purge_threshold=1e-10,\n)\n\nx0 = deepcopy(x00)\nx, v, primal, dual_gap, trajectoryBCG_simplex, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    epsilon=target_tolerance,\n    max_iteration=k,\n    line_search=FrankWolfe.Adaptive(L_est=L),\n    print_iter=k / 10,\n    hessian=hessian,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    accelerated=false,\n    verbose=true,\n    trajectory=true,\n    sparsity_control=1.0,\n    weight_purge_threshold=1e-10,\n)\n\nx0 = deepcopy(x00)\nx, v, primal, dual_gap, trajectoryBCG_convex, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    epsilon=target_tolerance,\n    max_iteration=k,\n    line_search=FrankWolfe.Adaptive(L_est=L),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=true,\n    trajectory=true,\n    sparsity_control=1.0,\n    weight_purge_threshold=1e-10,\n)\n\ndata = [trajectoryBCG_accel_simplex, trajectoryBCG_simplex, trajectoryBCG_convex]\nlabel = [\"BCG (accel simplex)\", \"BCG (simplex)\", \"BCG (convex)\"]\nplot_trajectories(data, label, xscalelog=true)\n\n\n\nmatrix = rand(n, n)\nhessian = transpose(matrix) * matrix\nlinear = rand(n)\nf(x) = dot(linear, x) + 0.5 * transpose(x) * hessian * x + 10\nfunction grad!(storage, x)\n    return storage .= linear + hessian * x\nend\nL = eigmax(hessian)\n\nlmo = FrankWolfe.KSparseLMO(100, 100.0)\nx00 = FrankWolfe.compute_extreme_point(lmo, zeros(n))\n\nx0 = deepcopy(x00)\nx, v, primal, dual_gap, trajectoryBCG_accel_simplex, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    epsilon=target_tolerance,\n    max_iteration=k,\n    line_search=FrankWolfe.Adaptive(L_est=L),\n    print_iter=k / 10,\n    hessian=hessian,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    accelerated=true,\n    verbose=true,\n    trajectory=true,\n    sparsity_control=1.0,\n    weight_purge_threshold=1e-10,\n)\n\nx0 = deepcopy(x00)\nx, v, primal, dual_gap, trajectoryBCG_simplex, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    epsilon=target_tolerance,\n    max_iteration=k,\n    line_search=FrankWolfe.Adaptive(L_est=L),\n    print_iter=k / 10,\n    hessian=hessian,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    accelerated=false,\n    verbose=true,\n    trajectory=true,\n    sparsity_control=1.0,\n    weight_purge_threshold=1e-10,\n)\n\nx0 = deepcopy(x00)\nx, v, primal, dual_gap, trajectoryBCG_convex, _ = FrankWolfe.blended_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0,\n    epsilon=target_tolerance,\n    max_iteration=k,\n    line_search=FrankWolfe.Adaptive(L_est=L),\n    print_iter=k / 10,\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    verbose=true,\n    trajectory=true,\n    sparsity_control=1.0,\n    weight_purge_threshold=1e-10,\n)\n\ndata = [trajectoryBCG_accel_simplex, trajectoryBCG_simplex, trajectoryBCG_convex]\nlabel = [\"BCG (accel simplex)\", \"BCG (simplex)\", \"BCG (convex)\"]\nplot_trajectories(data, label, xscalelog=true)","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"","category":"page"},{"location":"examples/docs_05_blended_cg/","page":"Blended Conditional Gradients","title":"Blended Conditional Gradients","text":"This page was generated using Literate.jl.","category":"page"},{"location":"advanced/#Advanced-features","page":"Advanced features","title":"Advanced features","text":"","category":"section"},{"location":"advanced/#Multi-precision","page":"Advanced features","title":"Multi-precision","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"All algorithms can run in various precisions modes: Float16, Float32, Float64, BigFloat and also for rationals based on various integer types Int32, Int64, BigInt (see e.g., the approximate Carathéodory example)","category":"page"},{"location":"advanced/#Step-size-computation","page":"Advanced features","title":"Step size computation","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"For all Frank-Wolfe algorithms, a step size must be determined to move from the current iterate to the next one. This step size can be determined by exact line search or any other rule represented by a subtype of FrankWolfe.LineSearchMethod, which must implement FrankWolfe.perform_line_search.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Multiple line search and step size determination rules are already  available. See Pedregosa, Negiar, Askari, Jaggi (2020) and Pokutta (2023) for the adaptive step size and Carderera, Besançon, Pokutta (2021) for the monotonic step size.","category":"page"},{"location":"advanced/#Callbacks","page":"Advanced features","title":"Callbacks","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"All top-level algorithms can take an optional callback argument, which must be a function taking a FrankWolfe.CallbackState struct and additional arguments:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"callback(state::FrankWolfe.CallbackState, args...)","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The callback can be used to log additional information or store some values of interest in an external array. If a callback is passed, the trajectory keyword is ignored since it is a special case of callback pushing the 5 first elements of the state to an array returned from the algorithm.","category":"page"},{"location":"advanced/#Custom-extreme-point-types","page":"Advanced features","title":"Custom extreme point types","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"For some feasible sets, the extreme points of the feasible set returned by the LMO possess a specific structure that can be represented in an efficient manner both for storage and for common operations like scaling and addition with an iterate. See for example FrankWolfe.ScaledHotVector and FrankWolfe.RankOneMatrix.","category":"page"},{"location":"advanced/#Active-set","page":"Advanced features","title":"Active set","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The active set represents an iterate as a convex combination of atoms (also referred to as extreme points or vertices). It maintains a vector of atoms, the corresponding weights, and the current iterate.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Note: the weights in the active set are currently defined as Float64 in the algorithm. This means that even with vertices using a lower precision, the iterate sum_i(lambda_i * v_i) will be upcast to Float64. One reason for keeping this as-is for now is the higher precision required by the computation of iterates from their barycentric decomposition.","category":"page"},{"location":"advanced/#Extra-lazification-with-a-vertex-storage","page":"Advanced features","title":"Extra-lazification with a vertex storage","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"One can pass the following keyword arguments to some active set-based Frank-Wolfe algorithms:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"add_dropped_vertices=true,\nuse_extra_vertex_storage=true,\nextra_vertex_storage=vertex_storage,","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"add_dropped_vertices activates feeding discarded vertices to the storage while use_extra_vertex_storage determines whether vertices from the storage are used in the algorithm. See Extra-lazification for a complete example.","category":"page"},{"location":"advanced/#Specialized-active-set-for-quadratic-functions","page":"Advanced features","title":"Specialized active set for quadratic functions","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"If the objective function is quadratic, a considerable speedup can be obtained by using the structure ActiveSetQuadraticProductCaching. It relies on the storage of various scalar products to efficiently determine the best (and worst for blended_pairwise_conditional_gradient) atom in the active set without the need of computing many scalar products in each iteration. The user should provide the Hessian matrix A as well as the linear part b of the function, such that:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"nabla f(x)=Ax+b","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"If the Hessian matrix A is simply a scaled identity (for a distance function for instance), LinearAlgebra.I or any LinearAlgebra.UniformScaling can be given. Note that these parameters can also be automatically detected, but the precision of this detection (which basically requires solving a linear system) soon becomes insufficient for practical purposes when the dimension increases.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"See the examples quadratic.jl and quadratic_A.jl for the exact syntax.","category":"page"},{"location":"advanced/#Miscellaneous","page":"Advanced features","title":"Miscellaneous","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Emphasis: All solvers support emphasis (parameter Emphasis) to either exploit vectorized linear algebra or be memory efficient, e.g., for large-scale instances\nVarious caching strategies for the lazy implementations. Unbounded cache sizes (can get slow), bounded cache sizes as well as early returns once any sufficient vertex is found in the cache.\nOptionally all algorithms can be endowed with gradient momentum. This might help convergence especially in the stochastic context.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Coming soon: when the LMO can compute dual prices, then the Frank-Wolfe algorithms will return dual prices for the (approximately) optimal solutions (see Braun, Pokutta (2021)).","category":"page"},{"location":"advanced/#Rational-arithmetic","page":"Advanced features","title":"Rational arithmetic","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Example: examples/approximateCaratheodory.jl","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"We can solve the approximate Carathéodory problem with rational arithmetic to obtain rational approximations; see Combettes, Pokutta 2019 for some background about approximate Carathéodory and Conditioanl Gradients. We consider the simple instance of approximating the 0 over the probability simplex here:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"min_x in Delta(n) x^2","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"with n = 100.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Vanilla Frank-Wolfe Algorithm.\nEMPHASIS: blas STEPSIZE: rationalshortstep EPSILON: 1.0e-7 max_iteration: 100 TYPE: Rational{BigInt}\n\n───────────────────────────────────────────────────────────────────────────────────\n  Type     Iteration         Primal           Dual       Dual Gap           Time\n───────────────────────────────────────────────────────────────────────────────────\n     I             0   1.000000e+00  -1.000000e+00   2.000000e+00   1.540385e-01\n    FW            10   9.090909e-02  -9.090909e-02   1.818182e-01   2.821186e-01\n    FW            20   4.761905e-02  -4.761905e-02   9.523810e-02   3.027964e-01\n    FW            30   3.225806e-02  -3.225806e-02   6.451613e-02   3.100331e-01\n    FW            40   2.439024e-02  -2.439024e-02   4.878049e-02   3.171654e-01\n    FW            50   1.960784e-02  -1.960784e-02   3.921569e-02   3.244207e-01\n    FW            60   1.639344e-02  -1.639344e-02   3.278689e-02   3.326185e-01\n    FW            70   1.408451e-02  -1.408451e-02   2.816901e-02   3.418239e-01\n    FW            80   1.234568e-02  -1.234568e-02   2.469136e-02   3.518750e-01\n    FW            90   1.098901e-02  -1.098901e-02   2.197802e-02   3.620287e-01\n  Last                 1.000000e-02   1.000000e-02   0.000000e+00   4.392171e-01\n───────────────────────────────────────────────────────────────────────────────────\n\n  0.600608 seconds (3.83 M allocations: 111.274 MiB, 12.97% gc time)\n\nOutput type of solution: Rational{BigInt}","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The solution returned is rational as we can see and in fact the exactly optimal solution:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"x = Rational{BigInt}[1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100, 1//100]","category":"page"},{"location":"advanced/#Large-scale-problems","page":"Advanced features","title":"Large-scale problems","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Example: examples/large_scale.jl","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The package is built to scale well, for those conditional gradients variants that can scale well. For example, Away-Step Frank-Wolfe and Pairwise Conditional Gradients do in most cases not scale well because they need to maintain active sets and maintaining them can be very expensive. Similarly, line search methods might become prohibitive at large sizes. However if we consider scale-friendly variants, e.g., the vanilla Frank-Wolfe algorithm with the agnostic step size rule or short step rule, then these algorithms can scale well to extreme sizes esentially only limited by the amount of memory available. However even for these methods that tend to scale well, allocation of memory itself can be very slow when you need to allocate gigabytes of memory for a single gradient computation.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The package is build to support extreme sizes with a special memory efficient emphasis emphasis=FrankWolfe.memory, which minimizes expensive memory allocations and performs as many operations in-place as possible.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Here is an example of a run with 1e9 variables. Each gradient is around 7.5 GB in size. Here is the output of the run broken down into pieces:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Size of single vector (Float64): 7629.39453125 MB\nTesting f... 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:00:23\nTesting grad... 100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:00:23\nTesting lmo... 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:00:29\nTesting dual gap... 100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:00:46\nTesting update... (Emphasis: blas) 100%|███████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:01:35\nTesting update... (Emphasis: memory) 100%|█████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:00:58\n ──────────────────────────────────────────────────────────────────────────\n                                   Time                   Allocations\n                           ──────────────────────   ───────────────────────\n     Tot / % measured:           278s / 31.4%            969GiB / 30.8%\n\n Section           ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────\n update (blas)         10    36.1s  41.3%   3.61s    149GiB  50.0%  14.9GiB\n lmo                   10    18.4s  21.1%   1.84s     0.00B  0.00%    0.00B\n grad                  10    12.8s  14.6%   1.28s   74.5GiB  25.0%  7.45GiB\n f                     10    12.7s  14.5%   1.27s   74.5GiB  25.0%  7.45GiB\n update (memory)       10    5.00s  5.72%   500ms     0.00B  0.00%    0.00B\n dual gap              10    2.40s  2.75%   240ms     0.00B  0.00%    0.00B\n ──────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The above is the optional benchmarking of the oracles that we provide to understand how fast crucial parts of the algorithms are, mostly notably oracle evaluations, the update of the iterate and the computation of the dual gap. As you can see if you compare update (blas) vs. update (memory), the normal update when we use BLAS requires an additional 14.9GB of memory on top of the gradient etc whereas the update (memory) (the memory emphasis mode) does not consume any extra memory. This is also reflected in the computational times: the BLAS version requires 3.61 seconds on average to update the iterate, while the memory emphasis version requires only 500ms. In fact none of the crucial components in the algorithm consume any memory when run in memory efficient mode. Now let us look at the actual footprint of the whole algorithm:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Vanilla Frank-Wolfe Algorithm.\nEMPHASIS: memory STEPSIZE: agnostic EPSILON: 1.0e-7 MAXITERATION: 1000 TYPE: Float64\nMOMENTUM: nothing GRADIENTTYPE: Nothing\nWARNING: In memory emphasis mode iterates are written back into x0!\n\n─────────────────────────────────────────────────────────────────────────────────────────────────\n  Type     Iteration         Primal           Dual       Dual Gap           Time         It/sec\n─────────────────────────────────────────────────────────────────────────────────────────────────\n     I             0   1.000000e+00  -1.000000e+00   2.000000e+00   8.783523e+00   0.000000e+00\n    FW           100   1.326732e-02  -1.326733e-02   2.653465e-02   4.635923e+02   2.157068e-01\n    FW           200   6.650080e-03  -6.650086e-03   1.330017e-02   9.181294e+02   2.178342e-01\n    FW           300   4.437059e-03  -4.437064e-03   8.874123e-03   1.372615e+03   2.185609e-01\n    FW           400   3.329174e-03  -3.329180e-03   6.658354e-03   1.827260e+03   2.189070e-01\n    FW           500   2.664003e-03  -2.664008e-03   5.328011e-03   2.281865e+03   2.191190e-01\n    FW           600   2.220371e-03  -2.220376e-03   4.440747e-03   2.736387e+03   2.192672e-01\n    FW           700   1.903401e-03  -1.903406e-03   3.806807e-03   3.190951e+03   2.193703e-01\n    FW           800   1.665624e-03  -1.665629e-03   3.331253e-03   3.645425e+03   2.194532e-01\n    FW           900   1.480657e-03  -1.480662e-03   2.961319e-03   4.099931e+03   2.195159e-01\n    FW          1000   1.332665e-03  -1.332670e-03   2.665335e-03   4.554703e+03   2.195533e-01\n  Last          1000   1.331334e-03  -1.331339e-03   2.662673e-03   4.559822e+03   2.195261e-01\n─────────────────────────────────────────────────────────────────────────────────────────────────\n\n4560.661203 seconds (7.41 M allocations: 112.121 GiB, 0.01% gc time)","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"As you can see the algorithm ran for about 4600 secs (single-thread run) allocating 112.121 GiB of memory throughout. So how does this average out to the per-iteration cost in terms of memory: 112.121 / 7.45 / 1000 = 0.0151 so about 15.1MiB per iteration which is much less than the size of the gradient and in fact only stems from the reporting here.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"NB. This example highlights also one of the great features of first-order methods and conditional gradients in particular: we have dimension-independent convergence rates. In fact, we contract the primal gap as 2LD^2 / (t+2) (for the simple agnostic rule) and, e.g., if the feasible region is the probability simplex with D = sqrt(2) and the function has bounded Lipschitzness, e.g., the function || x - xp ||^2 has L = 2, then the convergence rate is completely independent of the input size. The only thing that limits scaling is how much memory you have available and whether you can stomach the (linear) per-iteration cost.","category":"page"},{"location":"advanced/#Iterate-and-atom-expected-interface","page":"Advanced features","title":"Iterate and atom expected interface","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Frank-Wolfe can work on iterate beyond plain vectors, for example with any array-like object. Broadly speaking, the iterate type is assumed to behave as the member of a Hilbert space and optionally be mutable. Assuming the iterate type is IT, some methods must be implemented, with their usual semantics:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Base.similar(::IT)\nBase.similar(::IT, ::Type{T})\nBase.collect(::IT)\nBase.size(::IT)\nBase.eltype(::IT)\nBase.copyto!(dest::IT, src::IT)\n\nBase.:+(x1::IT, x2::IT)\nBase.:*(scalar::Real, x::IT)\nBase.:-(x1::IT, x2::IT)\nLinearAlgebra.dot(x1::IT, x2::IT)\nLinearAlgebra.norm(::IT)","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"For methods using an FrankWolfe.ActiveSet, the atoms or individual extreme points of the feasible region are not necessarily of the same type as the iterate. They are assumed to be immutable, must implement LinearAlgebra.dot with a gradient object. See for example FrankWolfe.RankOneMatrix or FrankWolfe.ScaledHotVector.","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"The iterate type IT must be a broadcastable mutable object or implement FrankWolfe.compute_active_set_iterate!:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"FrankWolfe.compute_active_set_iterate!(active_set::FrankWolfe.ActiveSet{AT, R, IT}) where {AT, R}","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"which recomputes the iterate from the current convex decomposition and the following methods FrankWolfe.active_set_update_scale! and FrankWolfe.active_set_update_iterate_pairwise!:","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"FrankWolfe.active_set_update_scale!(x::IT, lambda, atom)\nFrankWolfe.active_set_update_iterate_pairwise!(x::IT, lambda, fw_atom, away_atom)","category":"page"},{"location":"advanced/#Symmetry-reduction","page":"Advanced features","title":"Symmetry reduction","text":"","category":"section"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Example: examples/reynolds.jl","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Suppose that there is a group G acting on the underlying vector space and such that for all xinmathcalC and gin G","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"f(gcdot x)=f(x)quadtextandquad gcdot xinmathcalC","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"Then, the computations can be performed in the subspace invariant under G. This subspace is the image of the Reynolds operator defined by","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"mathcalR(x)=frac1Gsum_gin Ggcdot x","category":"page"},{"location":"advanced/","page":"Advanced features","title":"Advanced features","text":"In practice, the type SubspaceLMO allows the user to provide the Reynolds operator mathcalR as well as its adjoint mathcalR^ast. The gradient is symmetrised with mathcalR^ast, then passed to the non-symmetric LMO, and the resulting output is symmetrised with mathcalR. In many cases, the gradient is already symmetric so that reynolds_adjoint(gradient, lmo) = gradient is a fast and valid choice.","category":"page"},{"location":"reference/1_algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"This section contains all main algorithms of the package. These are the ones typical users will call.","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"The typical signature for these algorithms is:","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"my_algorithm(f, grad!, lmo, x0)","category":"page"},{"location":"reference/1_algorithms/#Standard-algorithms","page":"Algorithms","title":"Standard algorithms","text":"","category":"section"},{"location":"reference/1_algorithms/#FrankWolfe.frank_wolfe-NTuple{4, Any}","page":"Algorithms","title":"FrankWolfe.frank_wolfe","text":"frank_wolfe(f, grad!, lmo, x0; kwargs...)\n\nSimplest form of the Frank-Wolfe algorithm.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.lazified_conditional_gradient-NTuple{4, Any}","page":"Algorithms","title":"FrankWolfe.lazified_conditional_gradient","text":"lazified_conditional_gradient(f, grad!, lmo_base, x0; kwargs...)\n\nSimilar to FrankWolfe.frank_wolfe but lazyfying the LMO: each call is stored in a cache, which is looked up first for a good-enough direction. The cache used is a FrankWolfe.MultiCacheLMO or a FrankWolfe.VectorCacheLMO depending on whether the provided cache_size option is finite.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.stochastic_frank_wolfe-Tuple{FrankWolfe.StochasticObjective, Any, Any}","page":"Algorithms","title":"FrankWolfe.stochastic_frank_wolfe","text":"stochastic_frank_wolfe(f::StochasticObjective, lmo, x0; kwargs...)\n\nStochastic version of Frank-Wolfe, evaluates the objective and gradient stochastically, implemented through the FrankWolfe.StochasticObjective interface.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nSpecific keyword arguments\n\nKeyword arguments include batch_size to pass a fixed batch_size or a batch_iterator implementing batch_size = FrankWolfe.batchsize_iterate(batch_iterator) for algorithms like Variance-reduced and projection-free stochastic optimization, E Hazan, H Luo, 2016.\n\nSimilarly, a constant momentum can be passed or replaced by a momentum_iterator implementing momentum = FrankWolfe.momentum_iterate(momentum_iterator).\n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.block_coordinate_frank_wolfe","page":"Algorithms","title":"FrankWolfe.block_coordinate_frank_wolfe","text":"block_coordinate_frank_wolfe(f, grad!, lmo::ProductLMO{N}, x0; kwargs...) where {N}\n\nBlock-coordinate version of the Frank-Wolfe algorithm. Minimizes objective f over the product of feasible domains specified by the lmo. The optional argument the update_order is of type FrankWolfe.BlockCoordinateUpdateOrder and controls the order in which the blocks are updated. The argument update_step is a single instance or tuple of FrankWolfe.UpdateStep and defines which FW-algorithms to use to update the iterates in the different blocks.\n\nSee S. Lacoste-Julien, M. Jaggi, M. Schmidt, and P. Pletscher 2013 and A. Beck, E. Pauwels and S. Sabach 2015 for more details about Block-Coordinate Frank-Wolfe.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nThe method returns a tuple (x, v, primal, dual_gap, traj_data) with:\n\nx cartesian product of final iterates\nv cartesian product of last vertices of the LMOs\nprimal primal value f(x)\ndual_gap final Frank-Wolfe gap\ntraj_data vector of trajectory information.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Active-set-based-methods","page":"Algorithms","title":"Active-set based methods","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"The following algorithms maintain the representation of the iterates as a convex combination of vertices.","category":"page"},{"location":"reference/1_algorithms/#Away-step","page":"Algorithms","title":"Away-step","text":"","category":"section"},{"location":"reference/1_algorithms/#FrankWolfe.away_frank_wolfe-NTuple{4, Any}","page":"Algorithms","title":"FrankWolfe.away_frank_wolfe","text":"away_frank_wolfe(f, grad!, lmo, x0; kwargs...)\n\nFrank-Wolfe with away steps. The algorithm maintains the current iterate as a convex combination of vertices in the FrankWolfe.ActiveSet data structure. See M. Besançon, A. Carderera and S. Pokutta 2021 for illustrations of away steps.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data, active_set) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\nactive_set: the computed active set of vertices, of which the solution is a convex combination\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Pairwise-Frank-Wolfe","page":"Algorithms","title":"Pairwise Frank-Wolfe","text":"","category":"section"},{"location":"reference/1_algorithms/#FrankWolfe.blended_pairwise_conditional_gradient-NTuple{4, Any}","page":"Algorithms","title":"FrankWolfe.blended_pairwise_conditional_gradient","text":"blended_pairwise_conditional_gradient(f, grad!, lmo, x0; kwargs...)\n\nImplements the BPCG algorithm from Tsuji, Tanaka, Pokutta (2021). The method uses an active set of current vertices. Unlike away-step, it transfers weight from an away vertex to another vertex of the active set.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data, active_set) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\nactive_set: the computed active set of vertices, of which the solution is a convex combination\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.blended_pairwise_conditional_gradient-Union{Tuple{R}, Tuple{AT}, Tuple{Any, Any, Any, FrankWolfe.AbstractActiveSet{AT, R, IT} where IT}} where {AT, R}","page":"Algorithms","title":"FrankWolfe.blended_pairwise_conditional_gradient","text":"blended_pairwise_conditional_gradient(f, grad!, lmo, active_set::AbstractActiveSet; kwargs...)\n\nWarm-starts BPCG with a pre-defined active_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.pairwise_frank_wolfe-NTuple{4, Any}","page":"Algorithms","title":"FrankWolfe.pairwise_frank_wolfe","text":"pairwise_frank_wolfe(f, grad!, lmo, x0; kwargs...)\n\nFrank-Wolfe with pairwise steps. The algorithm maintains the current iterate as a convex combination of vertices in the FrankWolfe.ActiveSet data structure. See M. Besançon, A. Carderera and S. Pokutta 2021 for illustrations of away steps.  Unlike away-step, it transfers weight from an away vertex to another vertex.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data, active_set) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\nactive_set: the computed active set of vertices, of which the solution is a convex combination\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Blended-Conditional-Gradient","page":"Algorithms","title":"Blended Conditional Gradient","text":"","category":"section"},{"location":"reference/1_algorithms/#FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex-Tuple{Any, Any, Any, Any, Any, Any, FrankWolfe.AbstractActiveSet}","page":"Algorithms","title":"FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex","text":"accelerated_simplex_gradient_descent_over_probability_simplex\n\nMinimizes an objective function over the unit probability simplex until the Strong-Wolfe gap is below tolerance using Nesterov's accelerated gradient descent.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.blended_conditional_gradient-NTuple{4, Any}","page":"Algorithms","title":"FrankWolfe.blended_conditional_gradient","text":"blended_conditional_gradient(f, grad!, lmo, x0; kwargs...)\n\nEntry point for the Blended Conditional Gradient algorithm. See Braun, Gábor, et al. \"Blended conditonal gradients\" ICML 2019. The method works on an active set like FrankWolfe.away_frank_wolfe, performing gradient descent over the convex hull of active vertices, removing vertices when their weight drops to 0 and adding new vertices by calling the linear oracle in a lazy fashion.\n\nCommon arguments\n\nThese positional arguments are common to most Frank-Wolfe variants:\n\nf: a function f(x) computing the value of the objective to minimize at point x\ngrad!: a function grad!(g, x) overwriting g with the gradient of f at point x\nlmo: a linear minimization oracle, subtyping LinearMinimizationOracle\nx0: a starting point for the optimization (will be modified in-place for frank_wolfe with InplaceEmphasis)\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data, active_set) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\nactive_set: the computed active set of vertices, of which the solution is a convex combination\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var\"#s448\"} where var\"#s448\"<:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}","page":"Algorithms","title":"FrankWolfe.build_reduced_problem","text":"build_reduced_problem(atoms::AbstractVector{<:AbstractVector}, hessian, weights, gradient, tolerance)\n\nGiven an active set formed by vectors , a (constant) Hessian and a gradient constructs a quadratic problem over the unit probability simplex that is equivalent to minimizing the original function over the convex hull of the active set. If λ are the barycentric coordinates of dimension equal to the cardinality of the active set, the objective function is:\n\nf(λ) = reduced_linear^T λ + 0.5 * λ^T reduced_hessian λ\n\nIn the case where we find that the current iterate has a strong-Wolfe gap over the convex hull of the active set that is below the tolerance we return nothing (as there is nothing to do).\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.lp_separation_oracle-Tuple{FrankWolfe.LinearMinimizationOracle, FrankWolfe.AbstractActiveSet, Any, Any, Any}","page":"Algorithms","title":"FrankWolfe.lp_separation_oracle","text":"Returns either a tuple (y, val) with y an atom from the active set satisfying the progress criterion and val the corresponding gap dot(y, direction) or the same tuple with y from the LMO.\n\ninplace_loop controls whether the iterate type allows in-place writes. kwargs are passed on to the LMO oracle.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.minimize_over_convex_hull!-Union{Tuple{R}, Tuple{AT}, Tuple{Any, Any, Any, FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any, Any, Any, Any}} where {AT, R}","page":"Algorithms","title":"FrankWolfe.minimize_over_convex_hull!","text":"minimize_over_convex_hull!\n\nGiven a function f with gradient grad! and an active set active_set this function will minimize the function over the convex hull of the active set until the strong-wolfe gap over the active set is below tolerance.\n\nIt will either directly minimize over the convex hull using simplex gradient descent, or it will transform the problem to barycentric coordinates and minimize over the unit probability simplex using gradient descent or Nesterov's accelerated gradient descent.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.projection_simplex_sort-Tuple{Any}","page":"Algorithms","title":"FrankWolfe.projection_simplex_sort","text":"projection_simplex_sort(x; s=1.0)\n\nPerform a projection onto the probability simplex of radius s using a sorting algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.simplex_gradient_descent_over_convex_hull-Union{Tuple{R}, Tuple{AT}, Tuple{Any, Any, Any, FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any, Any, Any, Any}, Tuple{Any, Any, Any, FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any, Any, Any, Any, FrankWolfe.MemoryEmphasis}} where {AT, R}","page":"Algorithms","title":"FrankWolfe.simplex_gradient_descent_over_convex_hull","text":"simplex_gradient_descent_over_convex_hull(f, grad!, gradient, active_set, tolerance, t, time_start, non_simplex_iter)\n\nMinimizes an objective function over the convex hull of the active set until the Strong-Wolfe gap is below tolerance using simplex gradient descent.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.simplex_gradient_descent_over_probability_simplex-Tuple{Any, Any, Any, Any, Any, Any, Any, FrankWolfe.AbstractActiveSet}","page":"Algorithms","title":"FrankWolfe.simplex_gradient_descent_over_probability_simplex","text":"simplex_gradient_descent_over_probability_simplex\n\nMinimizes an objective function over the unit probability simplex until the Strong-Wolfe gap is below tolerance using gradient descent.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.strong_frankwolfe_gap-Tuple{Any}","page":"Algorithms","title":"FrankWolfe.strong_frankwolfe_gap","text":"Checks the strong Frank-Wolfe gap for the reduced problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.strong_frankwolfe_gap_probability_simplex-Tuple{Any, Any}","page":"Algorithms","title":"FrankWolfe.strong_frankwolfe_gap_probability_simplex","text":"strong_frankwolfe_gap_probability_simplex\n\nCompute the Strong-Wolfe gap over the unit probability simplex given a gradient.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Blended-Pairwise-Conditional-Gradient","page":"Algorithms","title":"Blended Pairwise Conditional Gradient","text":"","category":"section"},{"location":"reference/1_algorithms/#Corrective-Frank-Wolfe","page":"Algorithms","title":"Corrective Frank-Wolfe","text":"","category":"section"},{"location":"reference/1_algorithms/#FrankWolfe.corrective_frank_wolfe-Union{Tuple{R}, Tuple{AT}, Tuple{Any, Any, Any, FrankWolfe.CorrectiveStep, FrankWolfe.AbstractActiveSet{AT, R, IT} where IT}} where {AT, R}","page":"Algorithms","title":"FrankWolfe.corrective_frank_wolfe","text":"corrective_frank_wolfe(f, grad!, lmo, corrective_step, active_set::AS; kwargs...)\n\nA corrective Frank-Wolfe variant with corrective step defined by corrective_step.\n\nA corrective FW algorithm alternates between a standard FW step at which a vertex is added to the active set and a corrective step at which an update is performed in the convex hull of current vertices. Examples of corrective FW algorithms include blended (pairwise) conditional gradients, away-step Frank-Wolfe, and fully-corrective Frank-Wolfe.\n\nCommon keyword arguments\n\nThese keyword arguments are common to most Frank-Wolfe variants.\n\nwarning: Warning\nThe current variant may have additional keyword arguments, documented elsewhere, or it may only use a subset of the ones listed below. The default values of these arguments may also vary between variants, and thus are not part of the public API.\n\nline_search::LineSearchMethod: an object specifying the line search and its parameters (see LineSearchMethod)\nmomentum::Union{Real,Nothing}=nothing: constant momentum to apply to the gradient\nepsilon::Real: absolute dual gap threshold at which the algorithm is interrupted\nmax_iteration::Integer: maximum number of iterations after which the algorithm is interrupted\nprint_iter::Integer: interval between two consecutive log prints, expressed in number of iterations\ntrajectory::Bool=false: whether to record the trajectory of algorithm states (through callbacks)\nverbose::Bool: whether to print periodic logs (through callbacks)\nmemory_mode::MemoryEmphasis: an object dictating whether the algorithm operates in-place or out-of-place (see MemoryEmphasis)\ngradient=nothing: pre-allocated container for the gradient\ncallback=nothing: function called on a CallbackState at each iteration\ntraj_data=[]: pre-allocated storage for the trajectory of algorithm states\ntimeout::Real=Inf: maximum time after which the algorithm is interrupted (in nanoseconds)\nlinesearch_workspace=nothing: pre-allocated workspace for the line search \ndual_gap_compute_frequency::Integer=1: frequency of dual gap computation, \n\nReturn\n\nReturns a tuple (x, v, primal, dual_gap, traj_data, active_set) with:\n\nx: the final iterate\nv: the last vertex from the linear minimization oracle\nprimal: the final primal value f(x)\ndual_gap: the final Frank-Wolfe gap\ntraj_data: a vector of trajectory information, each element being the output of callback_state.\nactive_set: the computed active set of vertices, of which the solution is a convex combination\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.AwayStep","page":"Algorithms","title":"FrankWolfe.AwayStep","text":"(Lazified) away-step for corrective Frank-Wolfe\n\n\n\n\n\n","category":"type"},{"location":"reference/1_algorithms/#FrankWolfe.HybridPairAwayStep","page":"Algorithms","title":"FrankWolfe.HybridPairAwayStep","text":"Compares a pairwise and away step and chooses the one with most progress. The line search is computed for both steps. If one step incurs a drop, it is favored, otherwise the one decreasing the primal value the most is favored.\n\n\n\n\n\n","category":"type"},{"location":"reference/1_algorithms/#FrankWolfe.PairwiseStep","page":"Algorithms","title":"FrankWolfe.PairwiseStep","text":"Computes a classic pairwise step, i.e., d = v^FW - v^away.\n\n\n\n\n\n","category":"type"},{"location":"reference/1_algorithms/#FrankWolfe.prepare_corrective_step","page":"Algorithms","title":"FrankWolfe.prepare_corrective_step","text":"prepare_corrective_step(corrective_step::CS, f, grad!, gradient, active_set, t, lmo, primal, phi, tot_time) -> (should_compute_vertex, use_corrective)\n\nshould_compute_vertex is a boolean flag deciding whether a new vertex should be computed. use_corrective is a function that takes the vertex (the vertex is a valid new vertex only if shouldcomputevertex was true)\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#FrankWolfe.run_corrective_step","page":"Algorithms","title":"FrankWolfe.run_corrective_step","text":"run_corrective_step(corrective_step, f, grad!, gradient, x, active_set, t, lmo, line_search, linesearch_workspace, primal, phi, tot_time, callback, renorm_interval) -> (x, phi, primal)\n\nCorrective step method specific to the CS correctivestep type. The corrective step can perform whatever update over the current active set, the function should return the new iterate  a FW step should be run next with the boolean `shouldfw_stepand compute a new dual gap estimatephi`.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Alternating-Methods","page":"Algorithms","title":"Alternating Methods","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"Problems over intersections of convex sets, i.e.","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"min_x in bigcap_i=1^n P_i f(x)","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"pose a challenge as one has to combine the information of two or more LMOs.","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"FrankWolfe.alternating_linear_minimization converts the problem into a series of subproblems over single sets. To find a point within the intersection, one minimizes both the distance to the iterates of the other subproblems and the original objective function.","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"FrankWolfe.alternating_projections solves feasibility problems over intersections of feasible regions.","category":"page"},{"location":"reference/1_algorithms/#FrankWolfe.alternating_linear_minimization-Union{Tuple{LS}, Tuple{N}, Tuple{Any, Any, Any, Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, Tuple{Vararg{Any, N}}}} where {N, LS<:Union{Tuple{Vararg{FrankWolfe.LineSearchMethod, N}}, FrankWolfe.LineSearchMethod}}","page":"Algorithms","title":"FrankWolfe.alternating_linear_minimization","text":"alternating_linear_minimization(bc_algo::BlockCoordinateMethod, f, grad!, lmos::NTuple{N,LinearMinimizationOracle}, x0; ...) where {N}\n\nAlternating Linear Minimization minimizes the objective f over the intersections of the feasible domains specified by lmos. The tuple x0 defines the initial points for each domain. Returns a tuple (x, v, primal, dual_gap, dist2, traj_data) with:\n\nx cartesian product of final iterates\nv cartesian product of last vertices of the LMOs\nprimal primal value f(x)\ndual_gap final Frank-Wolfe gap\ndist2 is 1/2 of the sum of squared, pairwise distances between iterates\ntraj_data vector of trajectory information.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#FrankWolfe.alternating_projections-Union{Tuple{N}, Tuple{Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, Any}} where N","page":"Algorithms","title":"FrankWolfe.alternating_projections","text":"alternating_projections(lmos::NTuple{N,LinearMinimizationOracle}, x0; ...) where {N}\n\nComputes a point in the intersection of feasible domains specified by lmos. Returns a tuple (x, v, dual_gap, dist2, traj_data) with:\n\nx cartesian product of final iterates\nv cartesian product of last vertices of the LMOs\ndual_gap final Frank-Wolfe gap\ndist2 is 1/2 * sum of squared, pairwise distances between iterates\ntraj_data vector of trajectory information.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Index","page":"Algorithms","title":"Index","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"Pages = [\"2_algorithms.md\"]","category":"page"},{"location":"reference/0_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/0_reference/","page":"API Reference","title":"API Reference","text":"The pages in this section reference the documentation for specific types and functions.","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_03_matrix_completion/#Matrix-Completion","page":"Matrix Completion","title":"Matrix Completion","text":"","category":"section"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"We present another example that is about matrix completion. The idea is, given a partially observed matrix YinmathbbR^mtimes n, to find XinmathbbR^mtimes n to minimize the sum of squared errors from the observed entries while 'completing' the matrix Y, i.e. filling the unobserved entries to match Y as good as possible. A detailed explanation can be found in section 4.2 of the paper. We will try to solve","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"min_X_*le tau sum_(ij)inmathcalI (X_ij-Y_ij)^2","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"where tau0, X_* is the nuclear norm, and mathcalI denotes the indices of the observed entries. We will use FrankWolfe.NuclearNormLMO and compare our Frank-Wolfe implementation with a Projected Gradient Descent (PGD) algorithm which, after each gradient descent step, projects the iterates back onto the nuclear norm ball. We use a movielens dataset for comparison.","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"using FrankWolfe\nusing ZipFile, DataFrames, CSV\n\nusing Random\nusing Plots\n\nusing Profile\n\nimport Arpack\nusing SparseArrays, LinearAlgebra\n\nusing LaTeXStrings\n\ntemp_zipfile = download(\"http://files.grouplens.org/datasets/movielens/ml-latest-small.zip\")\n\nzarchive = ZipFile.Reader(temp_zipfile)\n\nmovies_file = zarchive.files[findfirst(f -> occursin(\"movies\", f.name), zarchive.files)]\nmovies_frame = CSV.read(movies_file, DataFrame)\n\nratings_file = zarchive.files[findfirst(f -> occursin(\"ratings\", f.name), zarchive.files)]\nratings_frame = CSV.read(ratings_file, DataFrame)\n\nusers = unique(ratings_frame[:, :userId])\nmovies = unique(ratings_frame[:, :movieId])\n\n@assert users == eachindex(users)\nmovies_revert = zeros(Int, maximum(movies))\nfor (idx, m) in enumerate(movies)\n    movies_revert[m] = idx\nend\nmovies_indices = [movies_revert[idx] for idx in ratings_frame[:, :movieId]]\n\nconst rating_matrix = sparse(\n    ratings_frame[:, :userId],\n    movies_indices,\n    ratings_frame[:, :rating],\n    length(users),\n    length(movies),\n)\n\nmissing_rate = 0.05\n\nRandom.seed!(42)\n\nconst missing_ratings = Tuple{Int,Int}[]\nconst present_ratings = Tuple{Int,Int}[]\nlet\n    (I, J, V) = SparseArrays.findnz(rating_matrix)\n    for idx in eachindex(I)\n        if V[idx] > 0\n            if rand() <= missing_rate\n                push!(missing_ratings, (I[idx], J[idx]))\n            else\n                push!(present_ratings, (I[idx], J[idx]))\n            end\n        end\n    end\nend\n\nfunction f(X)\n    r = 0.0\n    for (i, j) in present_ratings\n        r += 0.5 * (X[i, j] - rating_matrix[i, j])^2\n    end\n    return r\nend\n\nfunction grad!(storage, X)\n    storage .= 0\n    for (i, j) in present_ratings\n        storage[i, j] = X[i, j] - rating_matrix[i, j]\n    end\n    return nothing\nend\n\nfunction test_loss(X)\n    r = 0.0\n    for (i, j) in missing_ratings\n        r += 0.5 * (X[i, j] - rating_matrix[i, j])^2\n    end\n    return r\nend\n\nfunction project_nuclear_norm_ball(X; radius=1.0)\n    U, sing_val, Vt = svd(X)\n    if (sum(sing_val) <= radius)\n        return X, -norm_estimation * U[:, 1] * Vt[:, 1]'\n    end\n    sing_val = FrankWolfe.projection_simplex_sort(sing_val, s=radius)\n    return U * Diagonal(sing_val) * Vt', -norm_estimation * U[:, 1] * Vt[:, 1]'\nend\n\nnorm_estimation = 10 * Arpack.svds(rating_matrix, nsv=1, ritzvec=false)[1].S[1]\n\nconst lmo = FrankWolfe.NuclearNormLMO(norm_estimation)\nconst x0 = FrankWolfe.compute_extreme_point(lmo, ones(size(rating_matrix)))\nconst k = 10\n\ngradient = spzeros(size(x0)...)\ngradient_aux = spzeros(size(x0)...)\n\nfunction build_callback(trajectory_arr)\n    return function callback(state, args...)\n        return push!(trajectory_arr, (FrankWolfe.callback_state(state)..., test_loss(state.x)))\n    end\nend","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"The smoothness constant is estimated:","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"num_pairs = 100\nL_estimate = -Inf\nfor i in 1:num_pairs\n    global L_estimate\n    u1 = rand(size(x0, 1))\n    u1 ./= sum(u1)\n    u1 .*= norm_estimation\n    v1 = rand(size(x0, 2))\n    v1 ./= sum(v1)\n    x = FrankWolfe.RankOneMatrix(u1, v1)\n    u2 = rand(size(x0, 1))\n    u2 ./= sum(u2)\n    u2 .*= norm_estimation\n    v2 = rand(size(x0, 2))\n    v2 ./= sum(v2)\n    y = FrankWolfe.RankOneMatrix(u2, v2)\n    grad!(gradient, x)\n    grad!(gradient_aux, y)\n    new_L = norm(gradient - gradient_aux) / norm(x - y)\n    if new_L > L_estimate\n        L_estimate = new_L\n    end\nend","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"We can now perform projected gradient descent:","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"xgd = Matrix(x0)\nfunction_values = Float64[]\ntiming_values = Float64[]\nfunction_test_values = Float64[]\n\nls = FrankWolfe.Backtracking()\nls_storage = similar(xgd)\ntime_start = time_ns()\nfor _ in 1:k\n    f_val = f(xgd)\n    push!(function_values, f_val)\n    push!(function_test_values, test_loss(xgd))\n    push!(timing_values, (time_ns() - time_start) / 1e9)\n    @info f_val\n    grad!(gradient, xgd)\n    xgd_new, vertex = project_nuclear_norm_ball(xgd - gradient / L_estimate, radius=norm_estimation)\n    gamma = FrankWolfe.perform_line_search(\n        ls,\n        1,\n        f,\n        grad!,\n        gradient,\n        xgd,\n        xgd - xgd_new,\n        1.0,\n        ls_storage,\n        FrankWolfe.InplaceEmphasis(),\n    )\n    @. xgd -= gamma * (xgd - xgd_new)\nend\n\ntrajectory_arr_fw = Vector{Tuple{Int64,Float64,Float64,Float64,Float64,Float64}}()\ncallback = build_callback(trajectory_arr_fw)\nxfin, _, _, _, traj_data = FrankWolfe.frank_wolfe(\n    f,\n    grad!,\n    lmo,\n    x0;\n    epsilon=1e-9,\n    max_iteration=10 * k,\n    print_iter=k / 10,\n    verbose=false,\n    line_search=FrankWolfe.Adaptive(),\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    gradient=gradient,\n    callback=callback,\n)\n\ntrajectory_arr_lazy = Vector{Tuple{Int64,Float64,Float64,Float64,Float64,Float64}}()\ncallback = build_callback(trajectory_arr_lazy)\nxlazy, _, _, _, _ = FrankWolfe.lazified_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0;\n    epsilon=1e-9,\n    max_iteration=10 * k,\n    print_iter=k / 10,\n    verbose=false,\n    line_search=FrankWolfe.Adaptive(),\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    gradient=gradient,\n    callback=callback,\n)\n\n\ntrajectory_arr_lazy_ref = Vector{Tuple{Int64,Float64,Float64,Float64,Float64,Float64}}()\ncallback = build_callback(trajectory_arr_lazy_ref)\nxlazy, _, _, _, _ = FrankWolfe.lazified_conditional_gradient(\n    f,\n    grad!,\n    lmo,\n    x0;\n    epsilon=1e-9,\n    max_iteration=50 * k,\n    print_iter=k / 10,\n    verbose=false,\n    line_search=FrankWolfe.Adaptive(),\n    memory_mode=FrankWolfe.InplaceEmphasis(),\n    gradient=gradient,\n    callback=callback,\n)\n\nfw_test_values = getindex.(trajectory_arr_fw, 6)\nlazy_test_values = getindex.(trajectory_arr_lazy, 6)\n\nresults = Dict(\n    \"svals_gd\" => svdvals(xgd),\n    \"svals_fw\" => svdvals(xfin),\n    \"svals_lcg\" => svdvals(xlazy),\n    \"fw_test_values\" => fw_test_values,\n    \"lazy_test_values\" => lazy_test_values,\n    \"trajectory_arr_fw\" => trajectory_arr_fw,\n    \"trajectory_arr_lazy\" => trajectory_arr_lazy,\n    \"function_values_gd\" => function_values,\n    \"function_values_test_gd\" => function_test_values,\n    \"timing_values_gd\" => timing_values,\n    \"trajectory_arr_lazy_ref\" => trajectory_arr_lazy_ref,\n)\n\nref_optimum = results[\"trajectory_arr_lazy_ref\"][end][2]\n\niteration_list = [\n    [x[1] + 1 for x in results[\"trajectory_arr_fw\"]],\n    [x[1] + 1 for x in results[\"trajectory_arr_lazy\"]],\n    collect(1:1:length(results[\"function_values_gd\"])),\n]\ntime_list = [\n    [x[5] for x in results[\"trajectory_arr_fw\"]],\n    [x[5] for x in results[\"trajectory_arr_lazy\"]],\n    results[\"timing_values_gd\"],\n]\nprimal_gap_list = [\n    [x[2] - ref_optimum for x in results[\"trajectory_arr_fw\"]],\n    [x[2] - ref_optimum for x in results[\"trajectory_arr_lazy\"]],\n    [x - ref_optimum for x in results[\"function_values_gd\"]],\n]\ntest_list =\n    [results[\"fw_test_values\"], results[\"lazy_test_values\"], results[\"function_values_test_gd\"]]\n\nlabel = [L\"\\textrm{FW}\", L\"\\textrm{L-CG}\", L\"\\textrm{GD}\"]\n\nplot_results(\n    [primal_gap_list, primal_gap_list, test_list, test_list],\n    [iteration_list, time_list, iteration_list, time_list],\n    label,\n    [L\"\\textrm{Iteration}\", L\"\\textrm{Time}\", L\"\\textrm{Iteration}\", L\"\\textrm{Time}\"],\n    [\n        L\"\\textrm{Primal Gap}\",\n        L\"\\textrm{Primal Gap}\",\n        L\"\\textrm{Test Error}\",\n        L\"\\textrm{Test Error}\",\n    ],\n    xscalelog=[:log, :identity, :log, :identity],\n    legend_position=[:bottomleft, nothing, nothing, nothing],\n)","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"","category":"page"},{"location":"examples/docs_03_matrix_completion/","page":"Matrix Completion","title":"Matrix Completion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Accelerations-for-quadratic-functions-and-symmetric-problems","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"This example illustrates how to exploit symmetry to reduce the dimension of the problem via SubspaceLMO. Moreover, active set based algorithms can be accelerated by using the specialized structure ActiveSetQuadraticProductCaching.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"The specific problem we consider here comes from quantum information and some context can be found here. Formally, we want to find the distance between a tensor of size m^N and the N-partite local polytope which is defined by its vertices","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"d^veca^(1)ldots veca^(N)_x_1ldots x_Ncoloneqqprod_n=1^Na^(n)_x_n","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"labeled by veca^(n)=a^(n)_1ldots a^(n)_m for nin1N, where a^(n)_x=pm1. In the bipartite case (N=2), this polytope is affinely equivalent to the cut polytope.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Import-and-setup","page":"Accelerations for quadratic functions and symmetric problems","title":"Import and setup","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"We first import the necessary packages.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"import Combinatorics\nimport FrankWolfe\nimport LinearAlgebra\nimport Tullio","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"Then we can define our custom LMO, together with the method compute_extreme_point, which simply enumerates the vertices d^veca^(1) defined above. This structure is specialized for the case N=5 and contains pre-allocated fields used to accelerate the enumeration. Note that the output type (full tensor) is quite naive, but this is enough to illustrate the syntax in this toy example.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"struct BellCorrelationsLMO{T} <: FrankWolfe.LinearMinimizationOracle\n    m::Int # size of the tensor\n    tmp1::Array{T, 1}\n    tmp2::Array{T, 2}\n    tmp3::Array{T, 3}\n    tmp4::Array{T, 4}\nend\n\nfunction FrankWolfe.compute_extreme_point(lmo::BellCorrelationsLMO{T}, A::Array{T, 5}; kwargs...) where {T <: Number}\n    ax = [ones(T, lmo.m) for n in 1:5]\n    sc1 = zero(T)\n    sc2 = one(T)\n    axm = [zeros(T, lmo.m) for n in 1:5]\n    scm = typemax(T)\n    L = 2^lmo.m\n    aux = zeros(Int, lmo.m)\n    for λa5 in 0:(L÷2)-1\n        digits!(aux, λa5, base=2)\n        ax[5] .= 2aux .- 1\n        Tullio.@tullio lmo.tmp4[x1, x2, x3, x4] = A[x1, x2, x3, x4, x5] * ax[5][x5]\n        for λa4 in 0:L-1\n            digits!(aux, λa4, base=2)\n            ax[4] .= 2aux .- 1\n            Tullio.@tullio lmo.tmp3[x1, x2, x3] = lmo.tmp4[x1, x2, x3, x4] * ax[4][x4]\n            for λa3 in 0:L-1\n                digits!(aux, λa3, base=2)\n                ax[3] .= 2aux .- 1\n                Tullio.@tullio lmo.tmp2[x1, x2] = lmo.tmp3[x1, x2, x3] * ax[3][x3]\n                for λa2 in 0:L-1\n                    digits!(aux, λa2, base=2)\n                    ax[2] .= 2aux .- 1\n                    LinearAlgebra.mul!(lmo.tmp1, lmo.tmp2, ax[2])\n                    for x1 in 1:lmo.m\n                        ax[1][x1] = lmo.tmp1[x1] > zero(T) ? -one(T) : one(T)\n                    end\n                    sc = LinearAlgebra.dot(ax[1], lmo.tmp1)\n                    if sc < scm\n                        scm = sc\n                        for n in 1:5\n                            axm[n] .= ax[n]\n                        end\n                    end\n                end\n            end\n        end\n    end\n    return [axm[1][x1]*axm[2][x2]*axm[3][x3]*axm[4][x4]*axm[5][x5] for x1 in 1:lmo.m, x2 in 1:lmo.m, x3 in 1:lmo.m, x4 in 1:lmo.m, x5 in 1:lmo.m]\nend","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"Then we define our specific instance, coming from a GHZ state measured with measurements forming a regular polygon on the equator of the Bloch sphere. See this article for definitions and references.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"function correlation_tensor_GHZ_polygon(::Type{T}, N::Int, m::Int) where {T <: Number}\n    res = zeros(T, m*ones(Int, N)...)\n    tab_cos = [cos(x*T(pi)/m) for x in 0:N*m]\n    tab_cos[abs.(tab_cos) .< Base.rtoldefault(T)] .= zero(T)\n    for ci in CartesianIndices(res)\n        res[ci] = tab_cos[sum(ci.I)-N+1]\n    end\n    return res\nend\n\nT = Float64\nverbose = true\nmax_iteration = 10^4\nm = 5\np = 0.23correlation_tensor_GHZ_polygon(T, 5, m)\nx0 = zeros(T, size(p))\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"The objective function is simply frac12x-p_2^2, which we decompose in different terms for speed.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"normp2 = LinearAlgebra.dot(p, p) / 2\nf = let p = p, normp2 = normp2\n    x -> LinearAlgebra.dot(x, x) / 2 - LinearAlgebra.dot(p, x) + normp2\nend\ngrad! = let p = p\n    (storage, x) -> begin\n        @inbounds for i in eachindex(x)\n            storage[i] = x[i] - p[i]\n        end\n    end\nend\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Naive-run","page":"Accelerations for quadratic functions and symmetric problems","title":"Naive run","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"If we run the blended pairwise conditional gradient algorithm without modifications, convergence is not reached in 10000 iterations.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"lmo_naive = BellCorrelationsLMO{T}(m, zeros(T, m), zeros(T, m, m), zeros(T, m, m, m), zeros(T, m, m, m, m))\nFrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_naive, FrankWolfe.ActiveSet([(one(T), x0)]); verbose=false, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration=10) #hide\nas_naive = FrankWolfe.ActiveSet([(one(T), x0)])\n@time FrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_naive, as_naive; verbose, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration)\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Faster-active-set-for-quadratic-functions","page":"Accelerations for quadratic functions and symmetric problems","title":"Faster active set for quadratic functions","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"A first acceleration can be obtained by using the active set specialized for the quadratic objective function, whose gradient is here x-p, explaining the hessian and linear part provided as arguments. The speedup is obtained by pre-computing some scalar products to quickly obtained, in each iteration, the best and worst atoms currently in the active set.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"FrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_naive, FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0)], LinearAlgebra.I, -p); verbose=false, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration=10) #hide\nasq_naive = FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0)], LinearAlgebra.I, -p)\n@time FrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_naive, asq_naive; verbose, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration)\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"In this small example, the acceleration is quite minimal, but as soon as one of the following conditions is met, significant speedups (factor ten at least) can be expected:","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"quite expensive scalar product between atoms, for instance, due to a high dimension (say, more than 10000),\nhigh number of atoms in the active set (say, more than 1000),\nhigh number of iterations (say, more than 100000), spending most of the time redistributing the weights in the active set.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Dimension-reduction-via-symmetrization","page":"Accelerations for quadratic functions and symmetric problems","title":"Dimension reduction via symmetrization","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/#Permutation-of-the-tensor-axes","page":"Accelerations for quadratic functions and symmetric problems","title":"Permutation of the tensor axes","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"It is easy to see that our specific instance remains invariant under permutation of the dimensions of the tensor. This means that all computations can be performed in the symmetric subspace, which leads to an important speedup, owing to the reduced dimension (hence reduced size of the final active set and reduced number of iterations).","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"The way to operate this in the FrankWolfe package is to use a symmetrized LMO, which basically does the following:","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"symmetrize the gradient, which is not necessary here as the gradient remains symmetric throughout the algorithm,\ncall the standard LMO,\nsymmetrize its output, which amounts to averaging over its orbit with respect to the group considered (here the symmetric group permuting the dimensions of the tensor).","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"function reynolds_permutedims(atom::Array{T, N}, lmo::BellCorrelationsLMO{T}) where {T <: Number, N}\n    res = zeros(T, size(atom))\n    for per in Combinatorics.permutations(1:N)\n        res .+= permutedims(atom, per)\n    end\n    res ./= factorial(N)\n    return res\nend\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"Note that the second argument lmo is not used here but could in principle be exploited to obtain a very small speedup by precomputing and storing Combinatorics.permutations(1:N) in a dedicated field of our custom LMO.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"lmo_permutedims = FrankWolfe.SubspaceLMO(lmo_naive, reynolds_permutedims)\nFrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_permutedims, FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0)], LinearAlgebra.I, -p); verbose=false, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration=10) #hide\nasq_permutedims = FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0)], LinearAlgebra.I, -p)\n@time FrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_permutedims, asq_permutedims; verbose, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration)\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"Now, convergence is reached within 10000 iterations, and the size of the final active set is considerably smaller than before, thanks to the reduced dimension.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Uniqueness-pattern","page":"Accelerations for quadratic functions and symmetric problems","title":"Uniqueness pattern","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"In this specific case, there is a bigger symmetry group that we can exploit. Its action roughly allows us to work in the subspace respecting the structure of the objective point p, that is, to average over tensor entries that have the same value in p. Although quite general, this kind of symmetry is not always applicable, and great care has to be taken when using it, in particular, to ensure that there exists a suitable group action whose Reynolds operator corresponds to this averaging procedure. In our current case, the theoretical study enabling this further symmetrization can be found here.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"function build_reynolds_unique(p::Array{T, N}) where {T <: Number, N}\n    ptol = round.(p; digits=8)\n    ptol[ptol .== zero(T)] .= zero(T) # transform -0.0 into 0.0 as isequal(0.0, -0.0) is false\n    uniquetol = unique(ptol[:])\n    indices = [ptol .== u for u in uniquetol]\n    return function(A::Array{T, N}, lmo)\n        res = zeros(T, size(A))\n        for ind in indices\n            @view(res[ind]) .= sum(A[ind]) / sum(ind) # average over ind\n        end\n        return res\n    end\nend\n\nlmo_unique = FrankWolfe.SubspaceLMO(lmo_naive, build_reynolds_unique(p))\nFrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_unique, FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0)], LinearAlgebra.I, -p); verbose=false, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration=10) #hide\nasq_unique = FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0)], LinearAlgebra.I, -p)\n@time FrankWolfe.blended_pairwise_conditional_gradient(f, grad!, lmo_unique, asq_unique; verbose, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration)\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/#Reduction-of-the-memory-footprint-of-the-iterate","page":"Accelerations for quadratic functions and symmetric problems","title":"Reduction of the memory footprint of the iterate","text":"","category":"section"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"In the previous run, the dimension reduction is mathematically exploited to accelerate the algorithm, but it is not used to effectively work in a subspace of reduced dimension. Indeed, the iterate, although symmetric, was still a full tensor. As a last example of the speedup obtainable through symmetry reduction, we show how to map the computations into a space whose physical dimension is also reduced during the algorithm. This makes all in-place operations marginally faster, which can lead, in bigger instances, to significant accelerations, especially for active set based algorithms in the regime where many lazy iterations are performed. We refer to the example symmetric.jl for a small benchmark with symmetric matrices.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"function build_deflate_inflate(p::Array{T, N}) where {T <: Number, N}\n    ptol = round.(p; digits=8)\n    ptol[ptol .== zero(T)] .= zero(T) # transform -0.0 into 0.0 as isequal(0.0, -0.0) is false\n    uniquetol = unique(ptol[:])\n    dim = length(uniquetol) # reduced dimension\n    indices = [ptol .== u for u in uniquetol]\n    mul = [sum(ind) for ind in indices] # multiplicities, used to have matching scalar products\n    sqmul = sqrt.(mul) # precomputed for speed\n    return function(A::Array{T, N}, lmo)\n        vec = zeros(T, dim)\n        for (i, ind) in enumerate(indices)\n            vec[i] = sum(A[ind]) / sqmul[i]\n        end\n        return FrankWolfe.SubspaceVector(A, vec)\n    end, function(x::FrankWolfe.SubspaceVector, lmo)\n        for (i, ind) in enumerate(indices)\n            @view(x.data[ind]) .= x.vec[i] / sqmul[i]\n        end\n        return x.data\n    end\nend\n\ndeflate, inflate = build_deflate_inflate(p)\np_deflate = deflate(p, nothing)\nx0_deflate = deflate(x0, nothing)\nf_deflate = let p_deflate = p_deflate, normp2 = normp2\n    x -> LinearAlgebra.dot(x, x) / 2 - LinearAlgebra.dot(p_deflate, x) + normp2\nend\ngrad_deflate! = let p_deflate = p_deflate\n    (storage, x) -> begin\n        @inbounds for i in eachindex(x)\n            storage[i] = x[i] - p_deflate[i]\n        end\n    end\nend\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"Note that the objective function and its gradient have to be explicitly rewritten. In this simple example, their shape remains unchanged, but in general this may need some reformulation, which falls to the user.","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"lmo_deflate = FrankWolfe.SubspaceLMO(lmo_naive, deflate, inflate)\nFrankWolfe.blended_pairwise_conditional_gradient(f_deflate, grad_deflate!, lmo_deflate, FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0_deflate)], LinearAlgebra.I, -p_deflate); verbose=false, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration=10) #hide\nasq_deflate = FrankWolfe.ActiveSetQuadraticProductCaching([(one(T), x0_deflate)], LinearAlgebra.I, -p_deflate)\n@time FrankWolfe.blended_pairwise_conditional_gradient(f_deflate, grad_deflate!, lmo_deflate, asq_deflate; verbose, lazy=true, line_search=FrankWolfe.Shortstep(one(T)), max_iteration)\nprintln() #hide","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"","category":"page"},{"location":"examples/docs_12_quadratic_symmetric/","page":"Accelerations for quadratic functions and symmetric problems","title":"Accelerations for quadratic functions and symmetric problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/#Block-Coordinate-Frank-Wolfe-and-Block-Vectors","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"","category":"section"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"In this example, we demonstrate the usage of the FrankWolfe.block_coordinate_frank_wolfe and FrankWolfe.BlockVector. We consider the problem of minimizing the squared Euclidean distance between two sets. We compare different update orders and different update steps.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/#Import-and-setup","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Import and setup","text":"","category":"section"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"We first import the necessary packages and include the code for plotting the results.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"using FrankWolfe\nusing LinearAlgebra\n\ninclude(\"plot_utils.jl\")","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"Next, we define the objective function and its gradient. The iterates x are instances of the FrankWolfe.BlockVector type. The different blocks of the vector can be accessed via the blocks field.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"f(x) = dot(x.blocks[1] - x.blocks[2], x.blocks[1] - x.blocks[2])\n\nfunction grad!(storage, x)\n    @. storage.blocks = [x.blocks[1] - x.blocks[2], x.blocks[2] - x.blocks[1]]\nend","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"In our example we consider the probability simplex and an L-infinity norm ball as the feasible sets.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"n = 100\nlmo1 = FrankWolfe.ScaledBoundLInfNormBall(-ones(n), zeros(n))\nlmo2 = FrankWolfe.ProbabilitySimplexOracle(1.0)\nprod_lmo = FrankWolfe.ProductLMO((lmo1, lmo2))","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"We initialize the starting point x0 as a FrankWolfe.BlockVector with two blocks. The two other arguments are the block sizes and the overall number of entries.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"x0 = FrankWolfe.BlockVector([-ones(n), [i == 1 ? 1 : 0 for i in 1:n]], [(n,), (n,)], 2 * n);\nnothing #hide","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/#Running-block-coordinate-Frank-Wolfe-with-different-update-orders","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Running block-coordinate Frank-Wolfe with different update-orders","text":"","category":"section"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"In a first step, we compare different update orders. There are three different update orders implemented, FrankWolfe.FullUpdate, CyclicUpdate and Stochasticupdate. For creating a custome FrankWolfe.BlockCoordinateUpdateOrder, one needs to implement the function select_update_indices.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"struct CustomOrder <: FrankWolfe.BlockCoordinateUpdateOrder end\n\nfunction FrankWolfe.select_update_indices(::CustomOrder, state::FrankWolfe.CallbackState, dual_gaps)\n    return [rand() < 1 / n ? 1 : 2 for _ in 1:length(state.lmo.lmos)]\nend","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"We run the block-coordinate Frank-Wolfe method with the different update orders and store the trajectories.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"trajectories = []\n\nfor order in [\n    FrankWolfe.FullUpdate(),\n    FrankWolfe.CyclicUpdate(),\n    FrankWolfe.StochasticUpdate(),\n    CustomOrder(),\n]\n\n    _, _, _, _, traj_data = FrankWolfe.block_coordinate_frank_wolfe(\n        f,\n        grad!,\n        prod_lmo,\n        x0;\n        verbose=true,\n        trajectory=true,\n        update_order=order,\n    )\n    push!(trajectories, traj_data)\nend","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/#Plotting-the-results","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Plotting the results","text":"","category":"section"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"labels = [\"Full update\", \"Cyclic order\", \"Stochstic order\", \"Custom order\"]\nplot_trajectories(trajectories, labels, xscalelog=true)","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/#Running-BCFW-with-different-update-methods","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Running BCFW with different update methods","text":"","category":"section"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"As a second step, we compare different update steps. We consider the FrankWolfe.BPCGStep and the FrankWolfe.FrankWolfeStep. One can either pass a tuple of FrankWolfe.UpdateStep to define for each block the update procedure or pass a single update step so that each block uses the same procedure.","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"trajectories = []\n\nfor us in [(FrankWolfe.BPCGStep(), FrankWolfe.FrankWolfeStep()), (FrankWolfe.FrankWolfeStep(), FrankWolfe.BPCGStep()), FrankWolfe.BPCGStep(), FrankWolfe.FrankWolfeStep()]\n\n    _, _, _, _, traj_data = FrankWolfe.block_coordinate_frank_wolfe(\n        f,\n        grad!,\n        prod_lmo,\n        x0;\n        verbose=true,\n        trajectory=true,\n        update_step=us,\n    )\n    push!(trajectories, traj_data)\nend","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/#Plotting-the-results-2","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Plotting the results","text":"","category":"section"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"labels = [\"BPCG FW\", \"FW BPCG\", \"BPCG\", \"FW\"]\nplot_trajectories(trajectories, labels, xscalelog=true)","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"","category":"page"},{"location":"examples/docs_11_block_coordinate_fw/","page":"Block-Coordinate Frank-Wolfe and Block-Vectors","title":"Block-Coordinate Frank-Wolfe and Block-Vectors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"import FrankWolfe; include(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\")) # hide","category":"page"},{"location":"examples/docs_10_alternating_methods/#Alternating-methods","page":"Alternating methods","title":"Alternating methods","text":"","category":"section"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"In this example we will compare FrankWolfe.alternating_linear_minimization and FrankWolfe.alternating_projections for a very simple feasibility problem.","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"We consider the probability simplex","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"P =  x in mathbbR^n colon sum_i=1^n x_i = 1 x_i geq 0  i=1dotsn ","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"and a scaled, shifted ell^infty norm ball","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"Q = -10^n ","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"The goal is to find a point that lies both in P and Q. We do this by reformulating the problem first. Instead of a finding a point in the intersection P cap Q, we search for a pair of points, (x_P x_Q) in the cartesian product P times Q, which attains minimal distance between P and Q,","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"x_P - x_Q_2 = min_(xy) in P times Q x - y _2 ","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"using FrankWolfe\ninclude(\"../examples/plot_utils.jl\")","category":"page"},{"location":"examples/docs_10_alternating_methods/#Setting-up-objective,-gradient-and-linear-minimization-oracles","page":"Alternating methods","title":"Setting up objective, gradient and linear minimization oracles","text":"","category":"section"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"Alternating Linear Minimization (ALM) allows for an additional objective such that one can optimize over an intersection of sets instead of finding only feasible points. Since this example only considers the feasibility, we set the objective function as well as the gradient to zero.","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"n = 20\n\nf(x) = 0\n\nfunction grad!(storage, x)\n    @. storage = zero(x)\nend\n\n\nlmo1 = FrankWolfe.ProbabilitySimplexOracle(1.0)\nlmo2 = FrankWolfe.ScaledBoundLInfNormBall(-ones(n), zeros(n))\nlmos = (lmo1, lmo2)\n\nx0 = rand(n)\n\ntarget_tolerance = 1e-6\n\ntrajectories = [];\nnothing #hide","category":"page"},{"location":"examples/docs_10_alternating_methods/#Running-Alternating-Linear-Minimization","page":"Alternating methods","title":"Running Alternating Linear Minimization","text":"","category":"section"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"The method FrankWolfe.alternating_linear_minimization is not a FrankWolfe method itself. It is a wrapper translating a problem over the intersection of multiple sets to a problem over the product space. ALM can be called with any FW method. The default choice though is FrankWolfe.block_coordinate_frank_wolfe as it allows to update the blocks separately. There are three different update orders implemented, FullUpdate, CyclicUpdate and Stochasticupdate. Accordingly both blocks are updated either simulatenously, sequentially or in random order.","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"for order in [FrankWolfe.FullUpdate(), FrankWolfe.CyclicUpdate(), FrankWolfe.StochasticUpdate()]\n\n    _, _, _, _, _, alm_trajectory = FrankWolfe.alternating_linear_minimization(\n        FrankWolfe.block_coordinate_frank_wolfe,\n        f,\n        grad!,\n        lmos,\n        x0,\n        update_order=order,\n        verbose=true,\n        trajectory=true,\n        epsilon=target_tolerance,\n    )\n    push!(trajectories, alm_trajectory)\nend","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"As an alternative to Block-Coordiante Frank-Wolfe (BCFW), one can also run alternating linear minimization with standard Frank-Wolfe algorithm. These methods perform then the full (simulatenous) update at each iteration. In this example we also use FrankWolfe.away_frank_wolfe.","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"_, _, _, _, _, afw_trajectory = FrankWolfe.alternating_linear_minimization(\n    FrankWolfe.away_frank_wolfe,\n    f,\n    grad!,\n    lmos,\n    x0,\n    verbose=true,\n    trajectory=true,\n    epsilon=target_tolerance,\n)\npush!(trajectories, afw_trajectory);\nnothing #hide","category":"page"},{"location":"examples/docs_10_alternating_methods/#Running-Alternating-Projections","page":"Alternating methods","title":"Running Alternating Projections","text":"","category":"section"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"Unlike ALM, Alternating Projections (AP) is only suitable for feasibility problems. One omits the objective and gradient as parameters.","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"_, _, _, _, ap_trajectory = FrankWolfe.alternating_projections(\n    lmos,\n    x0,\n    trajectory=true,\n    verbose=true,\n    print_iter=100,\n    epsilon=target_tolerance,\n)\npush!(trajectories, ap_trajectory);\nnothing #hide","category":"page"},{"location":"examples/docs_10_alternating_methods/#Plotting-the-resulting-trajectories","page":"Alternating methods","title":"Plotting the resulting trajectories","text":"","category":"section"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"labels = [\"BCFW - Full\", \"BCFW - Cyclic\", \"BCFW - Stochastic\", \"AFW\", \"AP\"]\n\nplot_trajectories(trajectories, labels, xscalelog=true)","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"","category":"page"},{"location":"examples/docs_10_alternating_methods/","page":"Alternating methods","title":"Alternating methods","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FrankWolfe.jl","page":"Home","title":"FrankWolfe.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Dev) (Image: Stable) (Image: Coverage) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is a toolbox for Frank-Wolfe and conditional gradients algorithms.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Frank-Wolfe algorithms were designed to solve optimization problems of the form ","category":"page"},{"location":"","page":"Home","title":"Home","text":"min_x  C f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f is a differentiable convex function and C is a convex and compact set. They are especially useful when we know how to optimize a linear function over C in an efficient way.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A paper presenting the package with mathematical explanations and numerous examples can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"FrankWolfe.jl: A high-performance and flexible toolbox for Frank-Wolfe algorithms and Conditional Gradients.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The most recent release is available via the julia package manager, e.g., with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"FrankWolfe\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or the master branch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(url=\"https://github.com/ZIB-IOL/FrankWolfe.jl\", rev=\"master\")","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's say we want to solve the following minimization problem ","category":"page"},{"location":"","page":"Home","title":"Home","text":"min_p in  Δ(n) p_1^2 + dots + p_n^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Δ(n)= p in R^n_geq 0  p_1 + dots + p_n =1 is the probability simplex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using FrankWolfe.jl, let's write a minimal code solving this problem in dimension n=3. The main function is FrankWolfe.frank_wolfe and it requires: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"a function f that computes the values of the objective function f;\na function grad! that computes in-place the gradient of the objective function f;\na subtype of FrankWolfe.LinearMinimizationOracle for which a method of        FrankWolfe.compute_extreme_point has been implemented (see here);\na starting vector p0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using FrankWolfe\n\n# objective function f(p) = p_1^2 + ... + p_n^2\njulia> f(p) = sum(abs2, p)\n\n# in-place gradient computation for f thanks to '.='\njulia> grad!(storage, p) = storage .= 2p  \n\n# pre-defined type implementing the linear minimization oracle interface for the simplex\njulia> lmo = FrankWolfe.ProbabilitySimplexOracle(1.)\n\n# starting vector (of dimension n=3)\njulia> p0 = [1., 0., 0.]\n\n# an optimal solution is returned in p_opt\njulia> p_opt, _ = frank_wolfe(f, grad!, lmo, p0; verbose=true);\n\nVanilla Frank-Wolfe Algorithm.\nMEMORY_MODE: FrankWolfe.InplaceEmphasis() STEPSIZE: Adaptive EPSILON: 1.0e-7 MAXITERATION: 10000 TYPE: Float64\nMOMENTUM: nothing GRADIENTTYPE: Nothing\n[ Info: In memory_mode memory iterates are written back into x0!\n\n-------------------------------------------------------------------------------------------------\n  Type     Iteration         Primal           Dual       Dual Gap           Time         It/sec\n-------------------------------------------------------------------------------------------------\n     I             1   1.000000e+00  -1.000000e+00   2.000000e+00   0.000000e+00            Inf\n  Last            24   3.333333e-01   3.333332e-01   9.488992e-08   1.533181e+00   1.565373e+01\n-------------------------------------------------------------------------------------------------\n\njulia> p_opt\n3-element Vector{Float64}:\n 0.33333334349923327\n 0.33333332783841896\n 0.3333333286623478","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that active-set based methods like the Away-step Frank-Wolfe and Blended Pairwise Conditional Gradients also include a post-processing step.  In post-processing all values are recomputed and in particular the dual gap is computed at the current FW vertex, which might be slightly larger than the best dual gap observed as the gap is not monotonic. This is expected behavior.","category":"page"},{"location":"#Documentation-and-examples","page":"Home","title":"Documentation and examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To explore the content of the package, go to the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beyond those presented in the documentation, many more use cases are implemented in the examples folder. To run them, you will need to activate the test environment, which can be done simply with TestEnv.jl (we recommend you install it in your base Julia).","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TestEnv\n\njulia> TestEnv.activate()\n\"/tmp/jl_Ux8wKE/Project.toml\"\n\n# necessary for plotting\njulia> include(\"examples/plot_utils.jl\")\njulia> include(\"examples/linear_regression.jl\")\n...","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you need the plotting utilities in your own code, make sure Plots.jl is included in your current project and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nusing FrankWolfe\n\ninclude(joinpath(dirname(pathof(FrankWolfe)), \"../examples/plot_utils.jl\"))","category":"page"},{"location":"reference/3_backend/#Utilities-and-data-structures","page":"Utilities and data structures","title":"Utilities and data structures","text":"","category":"section"},{"location":"reference/3_backend/#Active-set","page":"Utilities and data structures","title":"Active set","text":"","category":"section"},{"location":"reference/3_backend/#FrankWolfe.AbstractActiveSet","page":"Utilities and data structures","title":"FrankWolfe.AbstractActiveSet","text":"AbstractActiveSet{AT, R, IT}\n\nAbstract type for an active set of atoms of type AT with weights of type R and iterate of type IT. An active set is typically expected to have a field weights, a field atoms, and a field x. Otherwise, all active set methods from src/active_set.jl can be overwritten.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.ActiveSet","page":"Utilities and data structures","title":"FrankWolfe.ActiveSet","text":"ActiveSet{AT, R, IT}\n\nRepresents an active set of extreme vertices collected in a FW algorithm, along with their coefficients (λ_i, a_i). R is the type of the λ_i, AT is the type of the atoms a_i. The iterate x = ∑λ_i a_i is stored in x with type IT.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#Base.copy-Union{Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT}}, Tuple{IT}, Tuple{R}, Tuple{AT}} where {AT, R, IT}","page":"Utilities and data structures","title":"Base.copy","text":"Copies an active set, the weight and atom vectors and the iterate. Individual atoms are not copied.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_add_weight!-Tuple{FrankWolfe.AbstractActiveSet, Real, Integer}","page":"Utilities and data structures","title":"FrankWolfe.active_set_add_weight!","text":"active_set_add_weight!(active_set, lambda, i)\n\nAdds lambda to the weight of the ith atom in active_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_argmin-Tuple{FrankWolfe.AbstractActiveSet, Any}","page":"Utilities and data structures","title":"FrankWolfe.active_set_argmin","text":"active_set_argmin(active_set::AbstractActiveSet, direction)\n\nComputes the linear minimizer in the direction on the active set. Returns (λ_i, a_i, i)\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_argminmax-Tuple{FrankWolfe.AbstractActiveSet, Any}","page":"Utilities and data structures","title":"FrankWolfe.active_set_argminmax","text":"active_set_argminmax(active_set::AbstractActiveSet, direction)\n\nComputes the linear minimizer in the direction on the active set. Returns (λ_min, a_min, i_min, val_min, λ_max, a_max, i_max, val_max, val_max-val_min ≥ Φ)\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_initialize!-Union{Tuple{R}, Tuple{AT}, Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any}} where {AT, R}","page":"Utilities and data structures","title":"FrankWolfe.active_set_initialize!","text":"active_set_initialize!(as, v)\n\nResets the active set structure to a single vertex v with unit weight.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_mul_weights!-Tuple{FrankWolfe.AbstractActiveSet, Real}","page":"Utilities and data structures","title":"FrankWolfe.active_set_mul_weights!","text":"active_set_mul_weights!(active_set, lambda)\n\nMultiplies all weights in active_set by lambda.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_update!-Union{Tuple{R}, Tuple{AT}, Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any, Any}, Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any, Any, Any}, Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Any, Any, Any, Any}} where {AT, R}","page":"Utilities and data structures","title":"FrankWolfe.active_set_update!","text":"active_set_update!(active_set::AbstractActiveSet, lambda, atom)\n\nAdds the atom to the active set with weight lambda or adds lambda to existing atom.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_update_iterate_pairwise!-Union{Tuple{A}, Tuple{IT}, Tuple{IT, Real, A, A}} where {IT, A}","page":"Utilities and data structures","title":"FrankWolfe.active_set_update_iterate_pairwise!","text":"active_set_update_iterate_pairwise!(active_set, x, lambda, fw_atom, away_atom)\n\nOperates x ← x + λ a_fw - λ a_aw.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_update_pairwise!-Union{Tuple{R}, Tuple{AT}, Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Real, Real, Integer, Integer, AT, AT, Bool}, Tuple{FrankWolfe.AbstractActiveSet{AT, R, IT} where IT, Real, Real, Integer, Integer, AT, AT, Bool, Any}} where {AT, R}","page":"Utilities and data structures","title":"FrankWolfe.active_set_update_pairwise!","text":"active_set_update_pairwise!(active_set, gamma, gamma_max, v_local_loc, a_loc, v_local, a, add_dropped_vertices, extra_vertex_storage)\n\nUpdates the active set for a pairwise step with step size gamma.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.active_set_update_scale!-Union{Tuple{IT}, Tuple{IT, Any, Any}} where IT","page":"Utilities and data structures","title":"FrankWolfe.active_set_update_scale!","text":"active_set_update_scale!(x, lambda, atom)\n\nOperates x ← (1-λ) x + λ a.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.compute_active_set_iterate!-Tuple{Any}","page":"Utilities and data structures","title":"FrankWolfe.compute_active_set_iterate!","text":"compute_active_set_iterate!(active_set::AbstractActiveSet) -> x\n\nRecomputes from scratch the iterate x from the current weights and vertices of the active set. Returns the iterate x.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.get_active_set_iterate-Tuple{Any}","page":"Utilities and data structures","title":"FrankWolfe.get_active_set_iterate","text":"get_active_set_iterate(active_set)\n\nReturn the current iterate corresponding. Does not recompute it.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.ActiveSetQuadraticProductCaching","page":"Utilities and data structures","title":"FrankWolfe.ActiveSetQuadraticProductCaching","text":"ActiveSetQuadraticProductCaching{AT, R, IT}\n\nRepresents an active set of extreme vertices collected in a FW algorithm, along with their coefficients (λ_i, a_i). R is the type of the λ_i, AT is the type of the atoms a_i. The iterate x = ∑λ_i a_i is stored in x with type IT. The objective function is assumed to be of the form f(x)=½⟨x,Ax⟩+⟨b,x⟩+c so that the gradient is simply ∇f(x)=Ax+b.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.ActiveSetQuadraticLinearSolve","page":"Utilities and data structures","title":"FrankWolfe.ActiveSetQuadraticLinearSolve","text":"ActiveSetQuadraticLinearSolve{AT, R, IT}\n\nRepresents an active set of extreme vertices collected in a FW algorithm, along with their coefficients (λ_i, a_i). R is the type of the λ_i, AT is the type of the atoms a_i. The iterate x = ∑λ_i a_i is stored in x with type IT. The objective function is assumed to be of the form f(x)=½⟨x,Ax⟩+⟨b,x⟩+c so that the gradient is ∇f(x)=Ax+b.\n\nThis active set stores an inner active_set that keeps track of the current set of vertices and convex decomposition. It therefore delegates all update, deletion, and addition operations to this inner active set. The weight, atoms, and x fields should only be accessed to read and are effectively the same objects as those in the inner active set. The flag wolfe_step determines whether to use a Wolfe step from the min-norm point algorithm or the normal direct solve. The Wolfe step solves the auxiliary subproblem over the affine hull of the current active set (instead of the convex hull).\n\nThe structure also contains a scheduler struct which is called with the should_solve_lp function. To define a new frequency at which the LP should be solved, one can define another scheduler struct and implement the corresponding method.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.ActiveSetQuadraticLinearSolve-Union{Tuple{H}, Tuple{R}, Tuple{AT}, Tuple{Array{Tuple{R, AT}, 1}, H, Any, Any}} where {AT, R, H}","page":"Utilities and data structures","title":"FrankWolfe.ActiveSetQuadraticLinearSolve","text":"ActiveSetQuadraticLinearSolve(tuple_values::Vector{Tuple{R,AT}}, A, b, lp_optimizer)\n\nCreates an ActiveSetQuadraticLinearSolve from the given Hessian A, linear term b and lp_optimizer by creating an inner ActiveSetQuadraticProductCaching active set.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.ActiveSetQuadraticLinearSolve-Union{Tuple{R}, Tuple{AT}, Tuple{Array{Tuple{R, AT}, 1}, Function, Any}} where {AT, R}","page":"Utilities and data structures","title":"FrankWolfe.ActiveSetQuadraticLinearSolve","text":"ActiveSetQuadraticLinearSolve(tuple_values::Vector{Tuple{R,AT}}, grad!::Function, lp_optimizer)\n\nCreates an ActiveSetQuadraticLinearSolve by computing the Hessian and linear term from grad!.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.solve_quadratic_activeset_lp!-Union{Tuple{FrankWolfe.ActiveSetQuadraticLinearSolve{AT, R, IT, H, BT, OT, AS, SF} where {BT, OT<:MathOptInterface.AbstractOptimizer, AS<:FrankWolfe.AbstractActiveSet, SF}}, Tuple{H}, Tuple{IT}, Tuple{R}, Tuple{AT}} where {AT, R, IT, H}","page":"Utilities and data structures","title":"FrankWolfe.solve_quadratic_activeset_lp!","text":"solve_quadratic_activeset_lp!(as::ActiveSetQuadraticLinearSolve{AT, R, IT, H}))\n\nSolves the auxiliary LP over the current active set. The method is specialized by type H of the Hessian matrix A.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#Functions-and-gradients","page":"Utilities and data structures","title":"Functions and gradients","text":"","category":"section"},{"location":"reference/3_backend/#FrankWolfe.ObjectiveFunction","page":"Utilities and data structures","title":"FrankWolfe.ObjectiveFunction","text":"ObjectiveFunction\n\nRepresents an objective function optimized by algorithms. Subtypes of ObjectiveFunction must implement at least\n\ncompute_value(::ObjectiveFunction, x) for primal value evaluation\ncompute_gradient(::ObjectiveFunction, x) for gradient evaluation.\n\nand optionally compute_value_gradient(::ObjectiveFunction, x) returning the (primal, gradient) pair. compute_gradient may always use the same storage and return a reference to it.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.SimpleFunctionObjective","page":"Utilities and data structures","title":"FrankWolfe.SimpleFunctionObjective","text":"SimpleFunctionObjective{F,G,S}\n\nAn objective function built from separate primal objective f(x) and in-place gradient function grad!(storage, x). It keeps an internal storage of type s used to evaluate the gradient in-place.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.StochasticObjective","page":"Utilities and data structures","title":"FrankWolfe.StochasticObjective","text":"StochasticObjective{F, G, XT, S}(f::F, grad!::G, xs::XT, storage::S)\n\nRepresents a composite function evaluated with stochastic gradient. f(θ, x) evaluates the loss for a single data point x and parameter θ. grad!(storage, θ, x) adds to storage the partial gradient with respect to data point x at parameter θ. xs must be an indexable iterable (Vector{Vector{Float64}} for instance). Functions using a StochasticObjective have optional keyword arguments rng, batch_size and full_evaluation controlling whether the function should be evaluated over all data points.\n\nNote: grad! must not reset the storage to 0 before adding to it.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.compute_gradient","page":"Utilities and data structures","title":"FrankWolfe.compute_gradient","text":"compute_gradient(f::ObjectiveFunction, x; [kwargs...])\n\nComputes the gradient of f at x. May return a reference to an internal storage.\n\n\n\n\n\n","category":"function"},{"location":"reference/3_backend/#FrankWolfe.compute_value","page":"Utilities and data structures","title":"FrankWolfe.compute_value","text":"compute_value(f::ObjectiveFunction, x; [kwargs...])\n\nComputes the objective f at x.\n\n\n\n\n\n","category":"function"},{"location":"reference/3_backend/#FrankWolfe.compute_value_gradient-Tuple{FrankWolfe.ObjectiveFunction, Any}","page":"Utilities and data structures","title":"FrankWolfe.compute_value_gradient","text":"compute_value_gradient(f::ObjectiveFunction, x; [kwargs...])\n\nComputes in one call the pair (value, gradient) evaluated at x. By default, calls compute_value and compute_gradient with keywords kwargs passed down to both.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#Callbacks","page":"Utilities and data structures","title":"Callbacks","text":"","category":"section"},{"location":"reference/3_backend/#FrankWolfe.CallbackState","page":"Utilities and data structures","title":"FrankWolfe.CallbackState","text":"CallbackState\n\nMain structure created before and passed to the callback in first position.\n\nFields\n\nt\nprimal\ndual\ndual_gap\ntime\nx\nv\nd\ngamma\nf\ngrad!\nlmo\ngradient\nstep_type\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#Custom-vertex-storage","page":"Utilities and data structures","title":"Custom vertex storage","text":"","category":"section"},{"location":"reference/3_backend/#Custom-extreme-point-types","page":"Utilities and data structures","title":"Custom extreme point types","text":"","category":"section"},{"location":"reference/3_backend/","page":"Utilities and data structures","title":"Utilities and data structures","text":"For some feasible sets, the extreme points of the feasible set returned by the LMO possess a specific structure that can be represented in an efficient manner both for storage and for common operations like scaling and addition with an iterate. They are presented below:","category":"page"},{"location":"reference/3_backend/#FrankWolfe.ScaledHotVector","page":"Utilities and data structures","title":"FrankWolfe.ScaledHotVector","text":"ScaledHotVector{T}\n\nRepresents a vector of at most one value different from 0.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.RankOneMatrix","page":"Utilities and data structures","title":"FrankWolfe.RankOneMatrix","text":"RankOneMatrix{T, UT, VT}\n\nRepresents a rank-one matrix R = u * vt'. Composes like a charm.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.SubspaceVector","page":"Utilities and data structures","title":"FrankWolfe.SubspaceVector","text":"SubspaceVector{HasMultiplicities, T}\n\nCompanion structure of SubspaceLMO containing three fields:\n\ndata is the full structure to be deflated,\nvec is a vector in the reduced subspace in which computations are performed,\nmul is only used to compute scalar products when HasMultiplicities = true,\n\nwhich should be avoided (when possible) for performance reasons.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#Utils","page":"Utilities and data structures","title":"Utils","text":"","category":"section"},{"location":"reference/3_backend/#FrankWolfe.ConstantBatchIterator","page":"Utilities and data structures","title":"FrankWolfe.ConstantBatchIterator","text":"ConstantBatchIterator(batch_size)\n\nBatch iterator always returning a constant batch size.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.ConstantMomentumIterator","page":"Utilities and data structures","title":"FrankWolfe.ConstantMomentumIterator","text":"ConstantMomentumIterator{T}\n\nIterator for momentum with a fixed damping value, always return the value and a dummy state.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.DeletedVertexStorage","page":"Utilities and data structures","title":"FrankWolfe.DeletedVertexStorage","text":"Vertex storage to store dropped vertices or find a suitable direction in lazy settings. The algorithm will look for at most return_kth suitable atoms before returning the best. See Extra-lazification with a vertex storage for usage.\n\nA vertex storage can be any type that implements two operations:\n\nBase.push!(storage, atom) to add an atom to the storage.\n\nNote that it is the storage type responsibility to ensure uniqueness of the atoms present.\n\nstorage_find_argmin_vertex(storage, direction, lazy_threshold) -> (found, vertex)\n\nreturning whether a vertex with sufficient progress was found and the vertex. It is up to the storage to remove vertices (or not) when they have been picked up.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.ExpMomentumIterator","page":"Utilities and data structures","title":"FrankWolfe.ExpMomentumIterator","text":"ExpMomentumIterator{T}\n\nIterator for the momentum used in the variant of Stochastic Frank-Wolfe. Momentum coefficients are the values of the iterator: ρ_t = 1 - num / (offset + t)^exp\n\nThe state corresponds to the iteration count.\n\nSource: Stochastic Conditional Gradient Methods: From Convex Minimization to Submodular Maximization Aryan Mokhtari, Hamed Hassani, Amin Karbasi, JMLR 2020.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.IncrementBatchIterator","page":"Utilities and data structures","title":"FrankWolfe.IncrementBatchIterator","text":"IncrementBatchIterator(starting_batch_size, max_batch_size, [increment = 1])\n\nBatch size starting at startingbatchsize and incrementing by increment at every iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.NegatingArray","page":"Utilities and data structures","title":"FrankWolfe.NegatingArray","text":"Given an array array, NegatingArray represents -1 * array lazily.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe._unsafe_equal-Tuple{Array, Array}","page":"Utilities and data structures","title":"FrankWolfe._unsafe_equal","text":"_unsafe_equal(a, b)\n\nLike isequal on arrays but without the checks. Assumes a and b have the same axes.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.batchsize_iterate","page":"Utilities and data structures","title":"FrankWolfe.batchsize_iterate","text":"batchsize_iterate(iter::BatchSizeIterator) -> b\n\nMethod to implement for a batch size iterator of type BatchSizeIterator. Calling batchsize_iterate returns the next batch size and typically update the internal state of iter.\n\n\n\n\n\n","category":"function"},{"location":"reference/3_backend/#FrankWolfe.momentum_iterate","page":"Utilities and data structures","title":"FrankWolfe.momentum_iterate","text":"momentum_iterate(iter::MomentumIterator) -> ρ\n\nMethod to implement for a type MomentumIterator. Returns the next momentum value ρ and updates the iterator internal state.\n\n\n\n\n\n","category":"function"},{"location":"reference/3_backend/#FrankWolfe.muladd_memory_mode-Tuple{FrankWolfe.MemoryEmphasis, Any, Any, Any}","page":"Utilities and data structures","title":"FrankWolfe.muladd_memory_mode","text":"muladd_memory_mode(memory_mode::MemoryEmphasis, d, x, v)\n\nPerforms d = x - v in-place or not depending on MemoryEmphasis\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.muladd_memory_mode-Tuple{FrankWolfe.MemoryEmphasis, Any, Any, Real, Any}","page":"Utilities and data structures","title":"FrankWolfe.muladd_memory_mode","text":"(memory_mode::MemoryEmphasis, storage, x, gamma::Real, d)\n\nPerforms storage = x - gamma * d in-place or not depending on MemoryEmphasis\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.muladd_memory_mode-Tuple{FrankWolfe.MemoryEmphasis, Any, Real, Any}","page":"Utilities and data structures","title":"FrankWolfe.muladd_memory_mode","text":"(memory_mode::MemoryEmphasis, x, gamma::Real, d)\n\nPerforms x = x - gamma * d in-place or not depending on MemoryEmphasis\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.pre_computed_set_argminmax-NTuple{4, Any}","page":"Utilities and data structures","title":"FrankWolfe.pre_computed_set_argminmax","text":"Computes the linear minimizer in the direction on the precomputedset. Precomputedset stores the vertices computed as extreme points v in each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.storage_find_argmin_vertex-Tuple{FrankWolfe.DeletedVertexStorage, Any, Any}","page":"Utilities and data structures","title":"FrankWolfe.storage_find_argmin_vertex","text":"Give the vertex v in the storage that minimizes s = direction ⋅ v and whether s achieves s ≤ lazy_threshold.\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#FrankWolfe.trajectory_callback-Tuple{Any}","page":"Utilities and data structures","title":"FrankWolfe.trajectory_callback","text":"trajectory_callback(storage)\n\nCallback pushing the state at each iteration to the passed storage. The state data is only the 5 first fields, usually: (t,primal,dual,dual_gap,time)\n\n\n\n\n\n","category":"method"},{"location":"reference/3_backend/#Oracle-counting-trackers","page":"Utilities and data structures","title":"Oracle counting trackers","text":"","category":"section"},{"location":"reference/3_backend/","page":"Utilities and data structures","title":"Utilities and data structures","text":"The following structures are wrapping given oracles to behave similarly but additionally track the number of calls.","category":"page"},{"location":"reference/3_backend/#FrankWolfe.TrackingObjective","page":"Utilities and data structures","title":"FrankWolfe.TrackingObjective","text":"A function acting like the normal objective f but tracking the number of calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.TrackingGradient","page":"Utilities and data structures","title":"FrankWolfe.TrackingGradient","text":"A function acting like the normal grad! but tracking the number of calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.TrackingLMO","page":"Utilities and data structures","title":"FrankWolfe.TrackingLMO","text":"TrackingLMO{LMO}(lmo)\n\nAn LMO wrapping another one and tracking the number of calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/","page":"Utilities and data structures","title":"Utilities and data structures","text":"Also see the example Tracking, counters and custom callbacks for Frank Wolfe.","category":"page"},{"location":"reference/3_backend/#Update-order-for-block-coordinate-methods","page":"Utilities and data structures","title":"Update order for block-coordinate methods","text":"","category":"section"},{"location":"reference/3_backend/","page":"Utilities and data structures","title":"Utilities and data structures","text":"Block-coordinate methods can be run with different update orders. All update orders are subtypes of FrankWolfe.BlockCoordinateUpdateOrder. They have to implement the method FrankWolfe.select_update_indices which selects which blocks to update in what order.","category":"page"},{"location":"reference/3_backend/#FrankWolfe.BlockCoordinateUpdateOrder","page":"Utilities and data structures","title":"FrankWolfe.BlockCoordinateUpdateOrder","text":"Update order for a block-coordinate method. A BlockCoordinateUpdateOrder must implement\n\nselect_update_indices(::BlockCoordinateUpdateOrder, s::CallbackState, dual_gaps)\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.select_update_indices","page":"Utilities and data structures","title":"FrankWolfe.select_update_indices","text":"select_update_indices(::BlockCoordinateUpdateOrder, s::CallbackState, dual_gaps)\n\nReturns a list of lists of the block indices. Each sublist represents one round of updates in an iteration. The indices in a list show which blocks should be updated parallely in one round. For example, a full update is given by [1:l] and a blockwise update by [[i] for i=1:l], where l is the number of blocks.\n\n\n\n\n\n","category":"function"},{"location":"reference/3_backend/#FrankWolfe.FullUpdate","page":"Utilities and data structures","title":"FrankWolfe.FullUpdate","text":"The full update initiates a parallel update of all blocks in one single round.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.CyclicUpdate","page":"Utilities and data structures","title":"FrankWolfe.CyclicUpdate","text":"The cyclic update initiates a sequence of update rounds. In each round only one block is updated. The order of the blocks is determined by the given order of the LMOs.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.StochasticUpdate","page":"Utilities and data structures","title":"FrankWolfe.StochasticUpdate","text":"The stochastic update initiates a sequence of update rounds. In each round only one block is updated. The order of the blocks is a random.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.LazyUpdate","page":"Utilities and data structures","title":"FrankWolfe.LazyUpdate","text":"The Lazy update order is discussed in \"Flexible block-iterative analysis for the Frank-Wolfe algorithm,\" by Braun, Pokutta, & Woodstock (2024).  'lazyblock' is an index of a computationally expensive block to update; 'refreshrate' describes the frequency at which we perform a full activation; and 'blocksize' describes the number of \"faster\" blocks (i.e., those excluding 'lazyblock') activated (chosen uniformly at random) during each of the \"faster\" iterations; for more detail, see the article. If  'block_size' is unspecified, this defaults to\n\n\n\nNote: This methodology is currently only proven to work with 'FrankWolfe.Shortstep' linesearches and a (not-yet implemented) adaptive method; see the article for details.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#Update-step-for-block-coordinate-Frank-Wolfe","page":"Utilities and data structures","title":"Update step for block-coordinate Frank-Wolfe","text":"","category":"section"},{"location":"reference/3_backend/","page":"Utilities and data structures","title":"Utilities and data structures","text":"Block-coordinate Frank-Wolfe (BCFW) can run different FW algorithms on different blocks. All update steps are subtypes of FrankWolfe.UpdateStep and implement FrankWolfe.update_iterate which defines one iteration of the corresponding method.","category":"page"},{"location":"reference/3_backend/#FrankWolfe.UpdateStep","page":"Utilities and data structures","title":"FrankWolfe.UpdateStep","text":"Update step for block-coordinate Frank-Wolfe. These are implementations of different FW-algorithms to be used in a blockwise manner. Each update step must implement\n\nupdate_iterate(\n    step::UpdateStep,\n    x,\n    lmo,\n    f,\n    gradient,\n    grad!,\n    dual_gap,\n    t,\n    line_search,\n    linesearch_workspace,\n    memory_mode,\n    epsilon,\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.update_iterate","page":"Utilities and data structures","title":"FrankWolfe.update_iterate","text":"update_iterate(\n    step::UpdateStep,\n    x,\n    lmo,\n    f,\n    gradient,\n    grad!,\n    dual_gap,\n    t,\n    line_search,\n    linesearch_workspace,\n    memory_mode,\n    epsilon,\n)\n\nExecutes one iteration of the defined FrankWolfe.UpdateStep and updates the iterate x implicitly. The function returns a tuple (dual_gap, v, d, gamma, step_type):\n\ndual_gap is the updated FrankWolfe gap\nv is the used vertex\nd is the update direction\ngamma is the applied step-size\nstep_type is the applied step-type\n\n\n\n\n\n","category":"function"},{"location":"reference/3_backend/#FrankWolfe.FrankWolfeStep","page":"Utilities and data structures","title":"FrankWolfe.FrankWolfeStep","text":"Implementation of the vanilla Frank-Wolfe algorithm as an update step for block-coordinate Frank-Wolfe.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#FrankWolfe.BPCGStep","page":"Utilities and data structures","title":"FrankWolfe.BPCGStep","text":"Implementation of the blended pairwise conditional gradient (BPCG) method as an update step for block-coordinate Frank-Wolfe.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#Block-vector","page":"Utilities and data structures","title":"Block vector","text":"","category":"section"},{"location":"reference/3_backend/#FrankWolfe.BlockVector","page":"Utilities and data structures","title":"FrankWolfe.BlockVector","text":"BlockVector{T, MT <: AbstractArray{T}, ST <: Tuple} <: AbstractVector{T}\n\nRepresents a vector consisting of blocks. T is the element type of the vector, MT is the type of the underlying data array, and ST is the type of the tuple representing the sizes of each block. Each block can be accessed with the blocks field, and the sizes of the blocks are stored in the block_sizes field.\n\n\n\n\n\n","category":"type"},{"location":"reference/3_backend/#Index","page":"Utilities and data structures","title":"Index","text":"","category":"section"},{"location":"reference/3_backend/","page":"Utilities and data structures","title":"Utilities and data structures","text":"Pages = [\"3_backend.md\"]","category":"page"}]
}
