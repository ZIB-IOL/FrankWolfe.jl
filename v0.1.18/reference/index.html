<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References ¬∑ FrankWolfe.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FrankWolfe.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/0_fw_visualized/">Visualization of Frank-Wolfe running on a 2-dimensional polytope</a></li><li><a class="tocitem" href="../examples/1_mathopt_lmo/">Comparison with MathOptInterface on a Probability Simplex</a></li><li><a class="tocitem" href="../examples/2_polynomial_regression/">Polynomial Regression</a></li><li><a class="tocitem" href="../examples/3_matrix_completion/">Matrix Completion</a></li><li><a class="tocitem" href="../examples/4_rational_opt/">Exact Optimization with Rational Arithmetic</a></li><li><a class="tocitem" href="../examples/5_blended_cg/">Blended Conditional Gradients</a></li><li><a class="tocitem" href="../examples/6_spectrahedron/">Spectrahedron</a></li><li><a class="tocitem" href="../examples/7_shifted_norm_polytopes/">FrankWolfe for scaled, shifted <span>$\ell^1$</span> and <span>$\ell^{\infty}$</span> norm balls</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li class="is-active"><a class="tocitem" href>References</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Linear-Minimization-Oracle"><span>Linear Minimization Oracle</span></a></li><li><a class="tocitem" href="#Functions-and-Structures"><span>Functions and Structures</span></a></li><li class="toplevel"><a class="tocitem" href="#Components"><span>Components</span></a></li><li><a class="tocitem" href="#Active-set-management"><span>Active set management</span></a></li><li><a class="tocitem" href="#Step-size-computation"><span>Step size computation</span></a></li><li><a class="tocitem" href="#Functions-and-Structures-2"><span>Functions and Structures</span></a></li><li><a class="tocitem" href="#Custom-extreme-point-types"><span>Custom extreme point types</span></a></li><li><a class="tocitem" href="#Batch-and-momentum-iterators"><span>Batch and momentum iterators</span></a></li></ul></li><li><a class="tocitem" href="../indexlist/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><p>This section contains all main algorithms of the <a href="https://github.com/ZIB-IOL/FrankWolfe.jl"><code>FrankWolfe.jl</code></a> package. These are the ones typical users will call.</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.frank_wolfe" href="#FrankWolfe.frank_wolfe"><code>FrankWolfe.frank_wolfe</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frank_wolfe(f, grad!, lmo, x0; ...)</code></pre><p>Simplest form of the Frank-Wolfe algorithm. Returns a tuple <code>(x, v, primal, dual_gap, traj_data)</code> with:</p><ul><li><code>x</code> final iterate</li><li><code>v</code> last vertex from the LMO</li><li><code>primal</code> primal value <code>f(x)</code></li><li><code>dual_gap</code> final Frank-Wolfe gap</li><li><code>traj_data</code> vector of trajectory information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/fw_algorithms.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.lazified_conditional_gradient" href="#FrankWolfe.lazified_conditional_gradient"><code>FrankWolfe.lazified_conditional_gradient</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lazified_conditional_gradient</code></pre><p>Similar to <a href="#FrankWolfe.frank_wolfe"><code>frank_wolfe</code></a> but lazyfying the LMO: each call is stored in a cache, which is looked up first for a good-enough direction. The cache used is a <a href="#FrankWolfe.MultiCacheLMO"><code>FrankWolfe.MultiCacheLMO</code></a> or a <a href="#FrankWolfe.VectorCacheLMO"><code>FrankWolfe.VectorCacheLMO</code></a> depending on whether the provided <code>cache_size</code> option is finite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/fw_algorithms.jl#L233-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.away_frank_wolfe" href="#FrankWolfe.away_frank_wolfe"><code>FrankWolfe.away_frank_wolfe</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">away_frank_wolfe</code></pre><p>Frank-Wolfe with away steps. The algorithm maintains the current iterate as a convex combination of vertices in the <a href="#FrankWolfe.ActiveSet"><code>FrankWolfe.ActiveSet</code></a> data structure. See the <a href="https://arxiv.org/abs/2104.06675">paper</a> for illustrations of away steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/afw.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.blended_conditional_gradient" href="#FrankWolfe.blended_conditional_gradient"><code>FrankWolfe.blended_conditional_gradient</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blended_conditional_gradient(f, grad!, lmo, x0)</code></pre><p>Entry point for the Blended Conditional Gradient algorithm. See Braun, G√°bor, et al. &quot;Blended conditonal gradients&quot; ICML 2019. The method works on an active set like <a href="#FrankWolfe.away_frank_wolfe"><code>FrankWolfe.away_frank_wolfe</code></a>, performing gradient descent over the convex hull of active vertices, removing vertices when their weight drops to 0 and adding new vertices by calling the linear oracle in a lazy fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.stochastic_frank_wolfe" href="#FrankWolfe.stochastic_frank_wolfe"><code>FrankWolfe.stochastic_frank_wolfe</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stochastic_frank_wolfe(f::StochasticObjective, lmo, x0; ...)</code></pre><p>Stochastic version of Frank-Wolfe, evaluates the objective and gradient stochastically, implemented through the <a href="@ref">FrankWolfe.StochasticObjective</a> interface.</p><p>Keyword arguments include <code>batch_size</code> to pass a fixed <code>batch_size</code> or a <code>batch_iterator</code> implementing <code>batch_size = FrankWolfe.batchsize_iterate(batch_iterator)</code> for algorithms like Variance-reduced and projection-free stochastic optimization, E Hazan, H Luo, 2016.</p><p>Similarly, a constant <code>momentum</code> can be passed or replaced by a <code>momentum_iterator</code> implementing <code>momentum = FrankWolfe.momentum_iterate(momentum_iterator)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/fw_algorithms.jl#L452-L465">source</a></section></article><h1 id="Linear-Minimization-Oracle"><a class="docs-heading-anchor" href="#Linear-Minimization-Oracle">Linear Minimization Oracle</a><a id="Linear-Minimization-Oracle-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Minimization-Oracle" title="Permalink"></a></h1><p>The Linear Minimization Oracle (LMO) is a key component called at each iteration of the FW algorithm. Given <span>$d\in \mathcal{X}$</span>, it returns a vertex of the feasible set:</p><p class="math-container">\[v\in \argmin_{x\in \mathcal{C}} \langle d,x \rangle.\]</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LinearMinimizationOracle" href="#FrankWolfe.LinearMinimizationOracle"><code>FrankWolfe.LinearMinimizationOracle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Supertype for linear minimization oracles.</p><p>All LMOs must implement <code>compute_extreme_point(lmo::LMO, direction)</code> and return a vector <code>v</code> of the appropriate type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L2-L7">source</a></section></article><p>All of them are subtypes of <a href="#FrankWolfe.LinearMinimizationOracle"><code>FrankWolfe.LinearMinimizationOracle</code></a> and implement the following method:</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point" href="#FrankWolfe.compute_extreme_point"><code>FrankWolfe.compute_extreme_point</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_extreme_point(lmo::LinearMinimizationOracle, direction; kwargs...)</code></pre><p>Computes the point <code>argmin_{v ‚àà C} v ‚ãÖ direction</code> with <code>C</code> the set represented by the LMO. Most LMOs feature <code>v</code> as a keyword argument that allows for an in-place computation whenever <code>v</code> is dense. All LMOs should accept keyword arguments that they can ignore.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L10-L17">source</a></section></article><p>The package features the following common LMOs out of the box:</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.BirkhoffPolytopeLMO" href="#FrankWolfe.BirkhoffPolytopeLMO"><code>FrankWolfe.BirkhoffPolytopeLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BirkhoffPolytopeLMO</code></pre><p>The Birkhoff polytope encodes doubly stochastic matrices. Its extreme vertices are all permutation matrices of side-dimension <code>dimension</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/polytope_oracles.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.KNormBallLMO" href="#FrankWolfe.KNormBallLMO"><code>FrankWolfe.KNormBallLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KNormBallLMO{T}(K::Int, right_hand_side::T)</code></pre><p>LMO with feasible set being the K-norm ball in the sense of <a href="https://arxiv.org/abs/2010.07243">2010.07243</a>, i.e., the convex hull over the union of an L<em>1-ball with radius œÑ and an L</em>‚àû-ball with radius œÑ/K:</p><pre><code class="nohighlight hljs">C_{K,œÑ} = conv { B_1(œÑ) ‚à™ B_‚àû(œÑ / K) }</code></pre><p>with <code>œÑ</code> the <code>right_hand_side</code> parameter. The K-norm is defined as the sum of the largest <code>K</code> absolute entries in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/norm_oracles.jl#L98-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.KSparseLMO" href="#FrankWolfe.KSparseLMO"><code>FrankWolfe.KSparseLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KSparseLMO{T}(K::Int, right_hand_side::T)</code></pre><p>LMO for the K-sparse polytope:</p><pre><code class="nohighlight hljs">C = B_1(œÑK) ‚à© B_‚àû(œÑ)</code></pre><p>with <code>œÑ</code> the <code>right_hand_side</code> parameter. The LMO results in a vector with the K largest absolute values of direction, taking values <code>-œÑ sign(x_i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/polytope_oracles.jl#L2-L12">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FrankWolfe.L1ballDense</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LpNormLMO" href="#FrankWolfe.LpNormLMO"><code>FrankWolfe.LpNormLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LpNormLMO{T, p}(right_hand_side)</code></pre><p>LMO with feasible set being an L-p norm ball:</p><pre><code class="nohighlight hljs">C = {x ‚àà R^n, norm(x, p) ‚â§ right_hand_side}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/norm_oracles.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.NuclearNormLMO" href="#FrankWolfe.NuclearNormLMO"><code>FrankWolfe.NuclearNormLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NuclearNormLMO{T}(radius)</code></pre><p>LMO over matrices that have a nuclear norm less than <code>radius</code>. The LMO returns the rank-one matrix with singular value <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/norm_oracles.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ProbabilitySimplexOracle" href="#FrankWolfe.ProbabilitySimplexOracle"><code>FrankWolfe.ProbabilitySimplexOracle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProbabilitySimplexOracle(right_side)</code></pre><p>Represents the scaled probability simplex:</p><pre><code class="nohighlight hljs">C = {x ‚àà R^n_+, ‚àëx = right_side}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/simplex_oracles.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ScaledBoundL1NormBall" href="#FrankWolfe.ScaledBoundL1NormBall"><code>FrankWolfe.ScaledBoundL1NormBall</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledBoundL1NormBall(lower_bounds, upper_bounds)</code></pre><p>Polytope similar to a L1-ball with shifted bounds. It is the convex hull of two scaled and shifted unit vectors for each axis (shifted to the center of the polytope, i.e., the elementwise midpoint of the bounds). Lower and upper bounds are passed on as abstract vectors, possibly of different types. For the standard L1-ball, all lower and upper bounds would be -1 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/polytope_oracles.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ScaledBoundLInfNormBall" href="#FrankWolfe.ScaledBoundLInfNormBall"><code>FrankWolfe.ScaledBoundLInfNormBall</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledBoundLInfNormBall(lower_bounds, upper_bounds)</code></pre><p>Polytope similar to a L-inf-ball with shifted bounds or general box constraints. Lower- and upper-bounds are passed on as abstract vectors, possibly of different types. For the standard L-inf ball, all lower- and upper-bounds would be -1 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/polytope_oracles.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.SpectraplexLMO" href="#FrankWolfe.SpectraplexLMO"><code>FrankWolfe.SpectraplexLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectraplexLMO{T,M}(radius::T,gradient_container::M,ensure_symmetry::Bool=true)</code></pre><p>Feasible set</p><pre><code class="nohighlight hljs">{X ‚àà ùïä_n^+, trace(X) == radius}</code></pre><p><code>gradient_container</code> is used to store the symmetrized negative direction. <code>ensure_symmetry</code> indicates whether the linear function is made symmetric before computing the eigenvector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/norm_oracles.jl#L182-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.UnitSimplexOracle" href="#FrankWolfe.UnitSimplexOracle"><code>FrankWolfe.UnitSimplexOracle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitSimplexOracle(right_side)</code></pre><p>Represents the scaled unit simplex:</p><pre><code class="nohighlight hljs">C = {x ‚àà R^n_+, ‚àëx ‚â§ right_side}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/simplex_oracles.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.UnitSpectrahedronLMO" href="#FrankWolfe.UnitSpectrahedronLMO"><code>FrankWolfe.UnitSpectrahedronLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitSpectrahedronLMO{T,M}(radius::T, gradient_container::M)</code></pre><p>Feasible set of PSD matrices with bounded trace:</p><pre><code class="nohighlight hljs">{X ‚àà ùïä_n^+, trace(X) ‚â§ radius}</code></pre><p><code>gradient_container</code> is used to store the symmetrized negative direction. <code>ensure_symmetry</code> indicates whether the linear function is made symmetric before computing the eigenvector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/norm_oracles.jl#L226-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MathOptLMO" href="#FrankWolfe.MathOptLMO"><code>FrankWolfe.MathOptLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MathOptLMO{OT &lt;: MOI.Optimizer} &lt;: LinearMinimizationOracle</code></pre><p>Linear minimization oracle with feasible space defined through a MathOptInterface.Optimizer. The oracle call sets the direction and reruns the optimizer.</p><p>The <code>direction</code> vector has to be set in the same order of variables as the <code>MOI.ListOfVariableIndices()</code> getter.</p><p>The Boolean <code>use_modify</code> determines if the objective in<code>compute_extreme_point</code> is updated with  <code>MOI.modify(o, ::MOI.ObjectiveFunction, ::MOI.ScalarCoefficientChange)</code> or with <code>MOI.set(o, ::MOI.ObjectiveFunction, f)</code>.  <code>use_modify = true</code> decreases the runtime and memory allocation for models created as an optimizer object and defined directly  with MathOptInterface. <code>use_modify = false</code> should be used for CachingOptimizers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/moi_oracle.jl#L2-L14">source</a></section></article><p>It also contains some meta-LMOs wrapping another one with extended behavior:</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.CachedLinearMinimizationOracle" href="#FrankWolfe.CachedLinearMinimizationOracle"><code>FrankWolfe.CachedLinearMinimizationOracle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachedLinearMinimizationOracle{LMO}</code></pre><p>Oracle wrapping another one of type lmo. Subtypes of <code>CachedLinearMinimizationOracle</code> contain a cache of previous solutions.</p><p>By convention, the inner oracle is named <code>inner</code>. Cached optimizers are expected to implement <code>Base.empty!</code> and <code>Base.length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ProductLMO" href="#FrankWolfe.ProductLMO"><code>FrankWolfe.ProductLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductLMO(lmos...)</code></pre><p>Linear minimization oracle over the Cartesian product of multiple LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.SingleLastCachedLMO" href="#FrankWolfe.SingleLastCachedLMO"><code>FrankWolfe.SingleLastCachedLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleLastCachedLMO{LMO, VT}</code></pre><p>Caches only the last result from an LMO and stores it in <code>last_vertex</code>. Vertices of <code>LMO</code> have to be of type <code>VT</code> if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MultiCacheLMO" href="#FrankWolfe.MultiCacheLMO"><code>FrankWolfe.MultiCacheLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiCacheLMO{N, LMO, VT}</code></pre><p>Cache for a LMO storing up to <code>N</code> vertices in the cache, removed in FIFO style. <code>oldest_idx</code> keeps track of the oldest index in the tuple, i.e. to replace next. <code>VT</code>, if provided, must be the type of vertices returned by <code>LMO</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.VectorCacheLMO" href="#FrankWolfe.VectorCacheLMO"><code>FrankWolfe.VectorCacheLMO</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorCacheLMO{N, LMO, VT}</code></pre><p>Cache for a LMO storing an unbounded number of vertices of type <code>VT</code> in the cache. <code>VT</code>, if provided, must be the type of vertices returned by <code>LMO</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L181-L186">source</a></section></article><p>See <a href="https://arxiv.org/abs/2101.10040">Combettes, Pokutta 2021</a> for references on most LMOs implemented in the package and their comparison with projection operators.</p><h2 id="Functions-and-Structures"><a class="docs-heading-anchor" href="#Functions-and-Structures">Functions and Structures</a><a id="Functions-and-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.ProductLMO, Tuple}" href="#FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.ProductLMO, Tuple}"><code>FrankWolfe.compute_extreme_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_extreme_point(lmo::ProductLMO, direction::Tuple; kwargs...)</code></pre><p>Extreme point computation on Cartesian product, with a direction <code>(d1, d2, ...)</code> given as a tuple of directions. All keyword arguments are passed to all LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L277-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{N}, Tuple{FrankWolfe.ProductLMO{N, TL} where TL&lt;:Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, AbstractArray}} where N" href="#FrankWolfe.compute_extreme_point-Union{Tuple{N}, Tuple{FrankWolfe.ProductLMO{N, TL} where TL&lt;:Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, AbstractArray}} where N"><code>FrankWolfe.compute_extreme_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_extreme_point(lmo::ProductLMO, direction::AbstractArray; direction_indices, storage=similar(direction))</code></pre><p>Extreme point computation, with a direction array and <code>direction_indices</code> provided such that: <code>direction[direction_indices[i]]</code> is passed to the i-th LMO. The result is stored in the optional <code>storage</code> container.</p><p>All keyword arguments are passed to all LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/oracles.jl#L287-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T" href="#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T"><code>FrankWolfe.compute_extreme_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>LMO for scaled unit simplex: <code>‚àë x_i = œÑ</code> Returns either vector of zeros or vector with one active value equal to RHS if there exists an improving direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/simplex_oracles.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T" href="#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T"><code>FrankWolfe.compute_dual_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Dual costs for a given primal solution to form a primal dual pair for scaled unit simplex. Returns two vectors. The first one is the dual costs associated with the constraints and the second is the reduced costs for the variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/simplex_oracles.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T" href="#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T"><code>FrankWolfe.compute_extreme_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>LMO for scaled probability simplex. Returns a vector with one active value equal to RHS in the most improving (or least degrading) direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/simplex_oracles.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T" href="#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T"><code>FrankWolfe.compute_dual_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Dual costs for a given primal solution to form a primal dual pair for scaled probability simplex. Returns two vectors. The first one is the dual costs associated with the constraints and the second is the reduced costs for the variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/simplex_oracles.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.NuclearNormLMO, AbstractMatrix{T} where T}" href="#FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.NuclearNormLMO, AbstractMatrix{T} where T}"><code>FrankWolfe.compute_extreme_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Best rank-one approximation using the greatest singular value computed with Arpack.</p><p>Warning: this does not work (yet) with all number types, BigFloat and Float16 fail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/norm_oracles.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.convert_mathopt" href="#FrankWolfe.convert_mathopt"><code>FrankWolfe.convert_mathopt</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_mathopt(lmo::LMO, optimizer::OT; kwargs...) -&gt; MathOptLMO{OT}</code></pre><p>Converts the given LMO to its equivalent MathOptInterface representation using <code>optimizer</code>. Must be implemented by LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/moi_oracle.jl#L122-L127">source</a></section></article><h1 id="Components"><a class="docs-heading-anchor" href="#Components">Components</a><a id="Components-1"></a><a class="docs-heading-anchor-permalink" href="#Components" title="Permalink"></a></h1><p>This section gathers all additional relevant components of the package.</p><h2 id="Active-set-management"><a class="docs-heading-anchor" href="#Active-set-management">Active set management</a><a id="Active-set-management-1"></a><a class="docs-heading-anchor-permalink" href="#Active-set-management" title="Permalink"></a></h2><p>The active set represents an iterate as a convex combination of atoms. It maintains a vector of atoms, the corresponding weights, and the current iterate.</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ActiveSet" href="#FrankWolfe.ActiveSet"><code>FrankWolfe.ActiveSet</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ActiveSet{AT, R, IT}</code></pre><p>Represents an active set of extreme vertices collected in a FW algorithm, along with their coefficients <code>(Œª_i, a_i)</code>. <code>R</code> is the type of the <code>Œª_i</code>, <code>AT</code> is the type of the atoms <code>a_i</code>. The iterate <code>x = ‚àëŒª_i a_i</code> is stored in x with type <code>IT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Union{Tuple{FrankWolfe.ActiveSet{AT, R, IT}}, Tuple{IT}, Tuple{R}, Tuple{AT}} where {AT, R, IT}" href="#Base.copy-Union{Tuple{FrankWolfe.ActiveSet{AT, R, IT}}, Tuple{IT}, Tuple{R}, Tuple{AT}} where {AT, R, IT}"><code>Base.copy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Copies an active set, the weight and atom vectors and the iterate. Individual atoms are not copied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L82-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_argmin-Tuple{FrankWolfe.ActiveSet, Any}" href="#FrankWolfe.active_set_argmin-Tuple{FrankWolfe.ActiveSet, Any}"><code>FrankWolfe.active_set_argmin</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">active_set_argmin(active_set::ActiveSet, direction)</code></pre><p>Computes the linear minimizer in the direction on the active set. Returns <code>(Œª_i, a_i, i)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_argminmax-Tuple{FrankWolfe.ActiveSet, Any}" href="#FrankWolfe.active_set_argminmax-Tuple{FrankWolfe.ActiveSet, Any}"><code>FrankWolfe.active_set_argminmax</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">active_set_argminmax(active_set::ActiveSet, direction)</code></pre><p>Computes the linear minimizer in the direction on the active set. Returns <code>(Œª_min, a_min, i_min, Œª_max, a_max, i_max)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_initialize!-Union{Tuple{R}, Tuple{AT}, Tuple{FrankWolfe.ActiveSet{AT, R, IT} where IT, Any}} where {AT, R}" href="#FrankWolfe.active_set_initialize!-Union{Tuple{R}, Tuple{AT}, Tuple{FrankWolfe.ActiveSet{AT, R, IT} where IT, Any}} where {AT, R}"><code>FrankWolfe.active_set_initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">active_set_initialize!(as, v)</code></pre><p>Resets the active set structure to a single vertex <code>v</code> with unit weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_update!" href="#FrankWolfe.active_set_update!"><code>FrankWolfe.active_set_update!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_set_update!(active_set::ActiveSet, lambda, atom)</code></pre><p>Adds the atom to the active set with weight lambda or adds lambda to existing atom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_active_set_iterate-Tuple{Any}" href="#FrankWolfe.compute_active_set_iterate-Tuple{Any}"><code>FrankWolfe.compute_active_set_iterate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_active_set_iterate(active_set)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L145-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.find_minmax_directions-Tuple{FrankWolfe.ActiveSet, Any, Any}" href="#FrankWolfe.find_minmax_directions-Tuple{FrankWolfe.ActiveSet, Any, Any}"><code>FrankWolfe.find_minmax_directions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_minmax_directions(active_set::ActiveSet, direction, Œ¶)</code></pre><p>Computes the point of the active set minimizing in <code>direction</code> on the active set (local Frank Wolfe) and the maximizing one (away step). Returns the two corresponding indices in the active set, along with a flag indicating if the direction improvement is above a threshold. <code>goodstep_tolerance ‚àà (0, 1]</code> is a tolerance coefficient multiplying Œ¶ for the validation of the progress. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/active_set.jl#L224-L233">source</a></section></article><h2 id="Step-size-computation"><a class="docs-heading-anchor" href="#Step-size-computation">Step size computation</a><a id="Step-size-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Step-size-computation" title="Permalink"></a></h2><p>For all Frank-Wolfe algorithms, a step size must be determined to move from the current iterate to the next one. This step size can be determined by exact line search or any other rule represented by a subtype of <code>LineSearchMethod</code> which must implement <code>line_search_wrapper</code>.</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.line_search_wrapper" href="#FrankWolfe.line_search_wrapper"><code>FrankWolfe.line_search_wrapper</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>line search wrapper NOTE: The stepsize is defined as x - gamma * d</p><p>Returns the step size gamma and the Lipschitz estimate L</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LineSearchMethod" href="#FrankWolfe.LineSearchMethod"><code>FrankWolfe.LineSearchMethod</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Line search method to apply once the direction is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/defs.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.adaptive_step_size" href="#FrankWolfe.adaptive_step_size"><code>FrankWolfe.adaptive_step_size</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Slight modification of Adaptive Step Size strategy from https://arxiv.org/pdf/1806.05123.pdf</p><p>Note: direction is opposite to the improving direction norm(gradient, direction) &gt; 0 TODO: </p><ul><li>make emphasis aware and optimize</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MonotonousStepSize" href="#FrankWolfe.MonotonousStepSize"><code>FrankWolfe.MonotonousStepSize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonotonousStepSize{F}</code></pre><p>Represents a monotonous open-loop step size. Contains a halving factor <code>N</code> increased at each iteration until there is primal progress <code>gamma = 2 / (t + 2) * 2^(-N)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L781-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MonotonousNonConvexStepSize" href="#FrankWolfe.MonotonousNonConvexStepSize"><code>FrankWolfe.MonotonousNonConvexStepSize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonotonousNonConvexStepSize{F}</code></pre><p>Represents a monotonous open-loop non-convex step size. Contains a halving factor <code>N</code> increased at each iteration until there is primal progress <code>gamma = 1 / sqrt(t + 1) * 2^(-N)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L824-L830">source</a></section></article><p>See <a href="https://arxiv.org/abs/1806.05123">Pedregosa, Negiar, Askari, Jaggi 2020</a> for the adaptive step size, <a href="https://openreview.net/forum?id=rq_UD6IiBpX">Carderera, Besan√ßon, Pokutta 2021</a> for the monotonous step size.</p><h2 id="Functions-and-Structures-2"><a class="docs-heading-anchor" href="#Functions-and-Structures-2">Functions and Structures</a><a class="docs-heading-anchor-permalink" href="#Functions-and-Structures-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.minimize_over_convex_hull!" href="#FrankWolfe.minimize_over_convex_hull!"><code>FrankWolfe.minimize_over_convex_hull!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimize_over_convex_hull!</code></pre><p>Given a function f with gradient grad! and an active set active_set this function will minimize the function over the convex hull of the active set until the strong-wolfe gap over the active set is below tolerance.</p><p>It will either directly minimize over the convex hull using simplex gradient descent, or it will transform the problem to barycentric coordinates and minimize over the unit probability simplex using gradient descent or Nesterov&#39;s accelerated gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L298-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}" href="#FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}"><code>FrankWolfe.build_reduced_problem</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_reduced_problem(atoms::AbstractVector{&lt;:AbstractVector}, hessian, weights, gradient, tolerance)</code></pre><p>Given an active set formed by vectors , a (constant) Hessian and a gradient constructs a quadratic problem over the unit probability simplex that is equivalent to minimizing the original function over the convex hull of the active set. If Œª are the barycentric coordinates of dimension equal to the cardinality of the active set, the objective function is:     f(Œª) = reduced<em>linear^T Œª + 0.5 * Œª^T reduced</em>hessian Œª</p><p>In the case where we find that the current iterate has a strong-Wolfe gap over the convex hull of the active set that is below the tolerance we return nothing (as there is nothing to do).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L446-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.strong_frankwolfe_gap" href="#FrankWolfe.strong_frankwolfe_gap"><code>FrankWolfe.strong_frankwolfe_gap</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Checks the strong Frank-Wolfe gap for the reduced problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L542-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex" href="#FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex"><code>FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accelerated_simplex_gradient_descent_over_probability_simplex</code></pre><p>Minimizes an objective function over the unit probability simplex until the Strong-Wolfe gap is below tolerance using Nesterov&#39;s accelerated gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L560-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.simplex_gradient_descent_over_probability_simplex" href="#FrankWolfe.simplex_gradient_descent_over_probability_simplex"><code>FrankWolfe.simplex_gradient_descent_over_probability_simplex</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplex_gradient_descent_over_probability_simplex</code></pre><p>Minimizes an objective function over the unit probability simplex until the Strong-Wolfe gap is below tolerance using gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L662-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.projection_simplex_sort" href="#FrankWolfe.projection_simplex_sort"><code>FrankWolfe.projection_simplex_sort</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">projection_simplex_sort(x; s=1.0)</code></pre><p>Perform a projection onto the probability simplex of radius <code>s</code> using a sorting algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L744-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.strong_frankwolfe_gap_probability_simplex" href="#FrankWolfe.strong_frankwolfe_gap_probability_simplex"><code>FrankWolfe.strong_frankwolfe_gap_probability_simplex</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strong_frankwolfe_gap_probability_simplex</code></pre><p>Compute the Strong-Wolfe gap over the unit probability simplex given a gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L764-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.simplex_gradient_descent_over_convex_hull" href="#FrankWolfe.simplex_gradient_descent_over_convex_hull"><code>FrankWolfe.simplex_gradient_descent_over_convex_hull</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplex_gradient_descent_over_convex_hull(f, grad!, gradient, active_set, tolerance, t, time_start, non_simplex_iter)</code></pre><p>Minimizes an objective function over the convex hull of the active set until the Strong-Wolfe gap is below tolerance using simplex gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L788-L794">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.lp_separation_oracle" href="#FrankWolfe.lp_separation_oracle"><code>FrankWolfe.lp_separation_oracle</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Returns either a tuple <code>(y, val)</code> with <code>y</code> an atom from the active set satisfying the progress criterion and <code>val</code> the corresponding gap <code>dot(y, direction)</code> or the same tuple with <code>y</code> from the LMO.</p><p><code>inplace_loop</code> controls whether the iterate type allows in-place writes. <code>kwargs</code> are passed on to the LMO oracle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/blended_cg.jl#L979-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.Emphasis" href="#FrankWolfe.Emphasis"><code>FrankWolfe.Emphasis</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Emphasis given to the algorithm for memory-saving or not. The memory-saving mode may not be faster than the default blas mode for small dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/defs.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ObjectiveFunction" href="#FrankWolfe.ObjectiveFunction"><code>FrankWolfe.ObjectiveFunction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveFunction</code></pre><p>Represents an objective function optimized by algorithms. Subtypes of <code>ObjectiveFunction</code> must implement at least</p><ul><li><code>compute_value(::ObjectiveFunction, x)</code> for primal value evaluation</li><li><code>compute_gradient(::ObjectiveFunction, x)</code> for gradient evaluation.</li></ul><p>and optionally <code>compute_value_gradient(::ObjectiveFunction, x)</code> returning the (primal, gradient) pair. <code>compute_gradient</code> may always use the same storage and return a reference to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/function_gradient.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_value_gradient" href="#FrankWolfe.compute_value_gradient"><code>FrankWolfe.compute_value_gradient</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_value_gradient(f::ObjectiveFunction, x; [kwargs...])</code></pre><p>Computes in one call the pair <code>(value, gradient)</code> evaluated at <code>x</code>. By default, calls <code>compute_value</code> and <code>compute_gradient</code> with keywords <code>kwargs</code> passed down to both.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/function_gradient.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.StochasticObjective" href="#FrankWolfe.StochasticObjective"><code>FrankWolfe.StochasticObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochasticObjective{F, G, XT, S}(f::F, grad!::G, xs::XT, storage::S)</code></pre><p>Represents a composite function evaluated with stochastic gradient. <code>f(Œ∏, x)</code> evaluates the loss for a single data point <code>x</code> and parameter <code>Œ∏</code>. <code>grad!(storage, Œ∏, x)</code> adds to storage the partial gradient with respect to data point <code>x</code> at parameter <code>Œ∏</code>. <code>xs</code> must be an indexable iterable (<code>Vector{Vector{Float64}}</code> for instance). Functions using a <code>StochasticObjective</code> have optional keyword arguments <code>rng</code>, <code>batch_size</code> and <code>full_evaluation</code> controlling whether the function should be evaluated over all data points.</p><p>Note: <code>grad!</code> must <strong>not</strong> reset the storage to 0 before adding to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/function_gradient.jl#L57-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.plot_results" href="#FrankWolfe.plot_results"><code>FrankWolfe.plot_results</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>plot_results</p><p>Given a series of list, generate subplots. list<em>data</em>y -&gt; contains a list of a list of lists (where each list refers to a subplot, and a list of lists refers to the y-values of the series inside a subplot). list<em>data</em>x -&gt; contains a list of a list of lists (where each list refers to a subplot, and a list of lists refers to the x-values of the series inside a subplot). So if we have one plot with two series, these might look like:     list<em>data</em>y = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]     list<em>data</em>x = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]</p><p>And if we have two plots, each with two series, these might look like:     list<em>data</em>y = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11, 12], [7, 8, 9, 10, 11, 12]]]     list<em>data</em>x = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11, 12], [7, 8, 9, 10, 11, 12]]]</p><p>list<em>label -&gt; contains the labels for the series that will be plotted, which has to have a length equal to the number of series that are being plotted:     list</em>label = [&quot;Series 1&quot;, &quot;Series 2&quot;]</p><p>list<em>axis</em>x -&gt; contains the labels for the x-axis that will be plotted,  which has to have a length equal to the number of subplots:      list<em>axis</em>x = [&quot;x-axis plot 1&quot;, &quot;x-axis plot 1&quot;]</p><p>list<em>axis</em>y -&gt; Same as list<em>axis</em>x but for the y-axis</p><p>xscalelog -&gt; A list of values indicating the type of axes to use in each subplot, must be equal to the number of subplots:     xscalelog = [:log, :identity]</p><p>yscalelog -&gt; Same as xscalelog but for the y-axis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L247-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.check_gradients" href="#FrankWolfe.check_gradients"><code>FrankWolfe.check_gradients</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Check if the gradient using finite differences matches the grad! provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L751-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.trajectory_callback" href="#FrankWolfe.trajectory_callback"><code>FrankWolfe.trajectory_callback</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trajectory_callback(storage)</code></pre><p>Callback pushing the state at each iteration to the passed storage. The state data is only the 5 first fields, usually: <code>(t,primal,dual,dual_gap,time)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L765-L771">source</a></section></article><p>A note on iterates precision in algorithms depending on an active set:   The weights in the active set are currently defined as <code>Float64</code> in the algorithm. This means that even with vertices using a lower precision, the iterate <code>sum_i(lambda_i * v_i)</code> will be upcast to <code>Float64</code>. One reason for keeping this as-is for now is the higher precision required by the computation of iterates from their barycentric decomposition.</p><h2 id="Custom-extreme-point-types"><a class="docs-heading-anchor" href="#Custom-extreme-point-types">Custom extreme point types</a><a id="Custom-extreme-point-types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-extreme-point-types" title="Permalink"></a></h2><p>For some feasible sets, the extreme points of the feasible set returned by the LMO possess a specific structure that can be represented in an efficient manner both for storage and for common operations like scaling and addition with an iterate. They are presented below:</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ScaledHotVector" href="#FrankWolfe.ScaledHotVector"><code>FrankWolfe.ScaledHotVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledHotVector{T}</code></pre><p>Represents a vector of at most one value different from 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.RankOneMatrix" href="#FrankWolfe.RankOneMatrix"><code>FrankWolfe.RankOneMatrix</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RankOneMatrix{T, UT, VT}</code></pre><p>Represents a rank-one matrix <code>R = u * vt&#39;</code>. Composes like a charm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/types.jl#L91-L96">source</a></section></article><h2 id="Batch-and-momentum-iterators"><a class="docs-heading-anchor" href="#Batch-and-momentum-iterators">Batch and momentum iterators</a><a id="Batch-and-momentum-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-and-momentum-iterators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.momentum_iterate" href="#FrankWolfe.momentum_iterate"><code>FrankWolfe.momentum_iterate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">momentum_iterate(iter::MomentumIterator) -&gt; œÅ</code></pre><p>Method to implement for a type <code>MomentumIterator</code>. Returns the next momentum value <code>œÅ</code> and updates the iterator internal state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L899-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ExpMomentumIterator" href="#FrankWolfe.ExpMomentumIterator"><code>FrankWolfe.ExpMomentumIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExpMomentumIterator{T}</code></pre><p>Iterator for the momentum used in the variant of Stochastic Frank-Wolfe. Momentum coefficients are the values of the iterator: <code>œÅ_t = 1 - num / (offset + t)^exp</code></p><p>The state corresponds to the iteration count.</p><p>Source: Stochastic Conditional Gradient Methods: From Convex Minimization to Submodular Maximization Aryan Mokhtari, Hamed Hassani, Amin Karbasi, JMLR 2020.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L907-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ConstantMomentumIterator" href="#FrankWolfe.ConstantMomentumIterator"><code>FrankWolfe.ConstantMomentumIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantMomentumIterator{T}</code></pre><p>Iterator for momentum with a fixed damping value, always return the value and a dummy state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L934-L938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.batchsize_iterate" href="#FrankWolfe.batchsize_iterate"><code>FrankWolfe.batchsize_iterate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batchsize_iterate(iter::BatchSizeIterator) -&gt; b</code></pre><p>Method to implement for a batch size iterator of type <code>BatchSizeIterator</code>. Calling <code>batchsize_iterate</code> returns the next batch size and typically update the internal state of <code>iter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L947-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ConstantBatchIterator" href="#FrankWolfe.ConstantBatchIterator"><code>FrankWolfe.ConstantBatchIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantBatchIterator(batch_size)</code></pre><p>Batch iterator always returning a constant batch size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L955-L959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.IncrementBatchIterator" href="#FrankWolfe.IncrementBatchIterator"><code>FrankWolfe.IncrementBatchIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IncrementBatchIterator(starting_batch_size, max_batch_size, [increment = 1])</code></pre><p>Batch size starting at starting<em>batch</em>size and incrementing by <code>increment</code> at every iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/837f136fa23418ea7536ff02f4aae38a9e8a23fc/src/utils.jl#L966-L970">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributing/">¬´ Contributing</a><a class="docs-footer-nextpage" href="../indexlist/">Index ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 8 February 2022 12:11">Tuesday 8 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
