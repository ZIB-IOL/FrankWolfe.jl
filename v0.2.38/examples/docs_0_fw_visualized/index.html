<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Visualization of Frank-Wolfe running on a 2-dimensional polytope · FrankWolfe.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FrankWolfe.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../basics/">How does it work?</a></li><li><a class="tocitem" href="../../advanced/">Advanced features</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Visualization of Frank-Wolfe running on a 2-dimensional polytope</a><ul class="internal"><li><a class="tocitem" href="#Import-and-setup"><span>Import and setup</span></a></li><li><a class="tocitem" href="#Custom-callback"><span>Custom callback</span></a></li><li><a class="tocitem" href="#Creating-the-Linear-Minimization-Oracle"><span>Creating the Linear Minimization Oracle</span></a></li><li><a class="tocitem" href="#Calling-Frank-Wolfe"><span>Calling Frank-Wolfe</span></a></li><li><a class="tocitem" href="#Plotting-the-algorithm-run"><span>Plotting the algorithm run</span></a></li></ul></li><li><a class="tocitem" href="../docs_10_alternating_methods/">Alternating methods</a></li><li><a class="tocitem" href="../docs_1_mathopt_lmo/">Comparison with MathOptInterface on a Probability Simplex</a></li><li><a class="tocitem" href="../docs_2_polynomial_regression/">Polynomial Regression</a></li><li><a class="tocitem" href="../docs_3_matrix_completion/">Matrix Completion</a></li><li><a class="tocitem" href="../docs_4_rational_opt/">Exact Optimization with Rational Arithmetic</a></li><li><a class="tocitem" href="../docs_5_blended_cg/">Blended Conditional Gradients</a></li><li><a class="tocitem" href="../docs_6_spectrahedron/">Spectrahedron</a></li><li><a class="tocitem" href="../docs_7_shifted_norm_polytopes/">FrankWolfe for scaled, shifted <span>$\ell^1$</span> and <span>$\ell^{\infty}$</span> norm balls</a></li><li><a class="tocitem" href="../docs_8_callback_and_tracking/">Tracking, counters and custom callbacks for Frank Wolfe</a></li><li><a class="tocitem" href="../docs_9_extra_vertex_storage/">Extra-lazification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/0_reference/">API Reference</a></li><li><a class="tocitem" href="../../reference/1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../../reference/2_lmo/">Linear Minimization Oracles</a></li><li><a class="tocitem" href="../../reference/3_backend/">Utilities and data structures</a></li><li><a class="tocitem" href="../../reference/4_linesearch/">Line search and step size settings</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Visualization of Frank-Wolfe running on a 2-dimensional polytope</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Visualization of Frank-Wolfe running on a 2-dimensional polytope</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/master/examples/docs_0_fw_visualized.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.check_gradients</code></pre><h1 id="Visualization-of-Frank-Wolfe-running-on-a-2-dimensional-polytope"><a class="docs-heading-anchor" href="#Visualization-of-Frank-Wolfe-running-on-a-2-dimensional-polytope">Visualization of Frank-Wolfe running on a 2-dimensional polytope</a><a id="Visualization-of-Frank-Wolfe-running-on-a-2-dimensional-polytope-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-Frank-Wolfe-running-on-a-2-dimensional-polytope" title="Permalink"></a></h1><p>This example provides an intuitive view of the Frank-Wolfe algorithm by running it on a polyhedral set with a quadratic function. The Linear Minimization Oracle (LMO) corresponds to a call to a generic simplex solver from <code>MathOptInterface.jl</code> (MOI).</p><h2 id="Import-and-setup"><a class="docs-heading-anchor" href="#Import-and-setup">Import and setup</a><a id="Import-and-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Import-and-setup" title="Permalink"></a></h2><p>We first import the necessary packages, including Polyhedra to visualize the feasible set.</p><pre><code class="language-julia hljs">using LinearAlgebra
using FrankWolfe

import MathOptInterface
const MOI = MathOptInterface
using GLPK

using Polyhedra
using Plots</code></pre><p>We can then define the objective function, here the squared distance to a point in the place, and its in-place gradient.</p><pre><code class="language-julia hljs">n = 2
y = [3.2, 0.5]

function f(x)
    return 1 / 2 * norm(x - y)^2
end
function grad!(storage, x)
    @. storage = x - y
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">grad! (generic function with 1 method)</code></pre><h2 id="Custom-callback"><a class="docs-heading-anchor" href="#Custom-callback">Custom callback</a><a id="Custom-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-callback" title="Permalink"></a></h2><p>FrankWolfe.jl lets users define custom callbacks to record information about each iteration. In that case, the callback will copy the current iterate <code>x</code>, the current vertex <code>v</code>, and the current step size <code>gamma</code> to an array thanks to a closure. We then declare the array and the callback over this array. Each iteration will then push to this array.</p><pre><code class="language-julia hljs">function build_callback(trajectory_arr)
    return function callback(state, args...)
        return push!(trajectory_arr, (copy(state.x), copy(state.v), state.gamma))
    end
end

iterates_information_vector = []
callback = build_callback(iterates_information_vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">callback (generic function with 1 method)</code></pre><h2 id="Creating-the-Linear-Minimization-Oracle"><a class="docs-heading-anchor" href="#Creating-the-Linear-Minimization-Oracle">Creating the Linear Minimization Oracle</a><a id="Creating-the-Linear-Minimization-Oracle-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Linear-Minimization-Oracle" title="Permalink"></a></h2><p>The LMO is defined as a call to a linear optimization solver, each iteration resets the objective and calls the solver. The linear constraints must be defined only once at the beginning and remain identical along iterations. We use here MathOptInterface directly but the constraints could also be defined with JuMP or Convex.jl.</p><pre><code class="language-julia hljs">o = GLPK.Optimizer()
x = MOI.add_variables(o, n)

# −x + y ≤ 2
c1 = MOI.add_constraint(o, -1.0x[1] + x[2], MOI.LessThan(2.0))

# x + 2 y ≤ 4
c2 = MOI.add_constraint(o, x[1] + 2.0x[2], MOI.LessThan(4.0))

# −2 x − y ≤ 1
c3 = MOI.add_constraint(o, -2.0x[1] - x[2], MOI.LessThan(1.0))

# x − 2 y ≤ 2
c4 = MOI.add_constraint(o, x[1] - 2.0x[2], MOI.LessThan(2.0))

# x ≤ 2
c5 = MOI.add_constraint(o, x[1] + 0.0x[2], MOI.LessThan(2.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}(5)</code></pre><p>The LMO is then built by wrapping the current MOI optimizer</p><pre><code class="language-julia hljs">lmo_moi = FrankWolfe.MathOptLMO(o)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FrankWolfe.MathOptLMO{GLPK.Optimizer}(A GLPK model, true)</code></pre><h2 id="Calling-Frank-Wolfe"><a class="docs-heading-anchor" href="#Calling-Frank-Wolfe">Calling Frank-Wolfe</a><a id="Calling-Frank-Wolfe-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-Frank-Wolfe" title="Permalink"></a></h2><p>We can now compute an initial starting point from any direction and call the Frank-Wolfe algorithm. Note that we copy <code>x0</code> before passing it to the algorithm because it is modified in-place by <code>frank_wolfe</code>.</p><pre><code class="language- hljs">x0 = FrankWolfe.compute_extreme_point(lmo_moi, zeros(n))

xfinal, vfinal, primal_value, dual_gap, traj_data = FrankWolfe.frank_wolfe(
    f,
    grad!,
    lmo_moi,
    copy(x0),
    line_search=FrankWolfe.Adaptive(),
    max_iteration=10,
    epsilon=1e-8,
    callback=callback,
    verbose=true,
    print_iter=1,
)</code></pre><p>We now collect the iterates and vertices across iterations.</p><pre><code class="language-julia hljs">iterates = Vector{Vector{Float64}}()
push!(iterates, x0)
vertices = Vector{Vector{Float64}}()
for s in iterates_information_vector
    push!(iterates, s[1])
    push!(vertices, s[2])
end</code></pre><h2 id="Plotting-the-algorithm-run"><a class="docs-heading-anchor" href="#Plotting-the-algorithm-run">Plotting the algorithm run</a><a id="Plotting-the-algorithm-run-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-algorithm-run" title="Permalink"></a></h2><p>We define another method for <code>f</code> adapted to plot its contours.</p><pre><code class="language-julia hljs">function f(x1, x2)
    x = [x1, x2]
    return f(x)
end

xlist = collect(range(-1, 3, step=0.2))
ylist = collect(range(-1, 3, step=0.2))

X = repeat(reshape(xlist, 1, :), length(ylist), 1)
Y = repeat(ylist, 1, length(xlist))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">21×21 Matrix{Float64}:
 -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  …  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0
 -0.8  -0.8  -0.8  -0.8  -0.8  -0.8     -0.8  -0.8  -0.8  -0.8  -0.8  -0.8
 -0.6  -0.6  -0.6  -0.6  -0.6  -0.6     -0.6  -0.6  -0.6  -0.6  -0.6  -0.6
 -0.4  -0.4  -0.4  -0.4  -0.4  -0.4     -0.4  -0.4  -0.4  -0.4  -0.4  -0.4
 -0.2  -0.2  -0.2  -0.2  -0.2  -0.2     -0.2  -0.2  -0.2  -0.2  -0.2  -0.2
  0.0   0.0   0.0   0.0   0.0   0.0  …   0.0   0.0   0.0   0.0   0.0   0.0
  0.2   0.2   0.2   0.2   0.2   0.2      0.2   0.2   0.2   0.2   0.2   0.2
  0.4   0.4   0.4   0.4   0.4   0.4      0.4   0.4   0.4   0.4   0.4   0.4
  0.6   0.6   0.6   0.6   0.6   0.6      0.6   0.6   0.6   0.6   0.6   0.6
  0.8   0.8   0.8   0.8   0.8   0.8      0.8   0.8   0.8   0.8   0.8   0.8
  ⋮                             ⋮    ⋱   ⋮                             ⋮
  1.4   1.4   1.4   1.4   1.4   1.4      1.4   1.4   1.4   1.4   1.4   1.4
  1.6   1.6   1.6   1.6   1.6   1.6      1.6   1.6   1.6   1.6   1.6   1.6
  1.8   1.8   1.8   1.8   1.8   1.8      1.8   1.8   1.8   1.8   1.8   1.8
  2.0   2.0   2.0   2.0   2.0   2.0  …   2.0   2.0   2.0   2.0   2.0   2.0
  2.2   2.2   2.2   2.2   2.2   2.2      2.2   2.2   2.2   2.2   2.2   2.2
  2.4   2.4   2.4   2.4   2.4   2.4      2.4   2.4   2.4   2.4   2.4   2.4
  2.6   2.6   2.6   2.6   2.6   2.6      2.6   2.6   2.6   2.6   2.6   2.6
  2.8   2.8   2.8   2.8   2.8   2.8      2.8   2.8   2.8   2.8   2.8   2.8
  3.0   3.0   3.0   3.0   3.0   3.0  …   3.0   3.0   3.0   3.0   3.0   3.0</code></pre><p>The feasible space is represented using Polyhedra.</p><pre><code class="language-julia hljs">h =
    HalfSpace([-1, 1], 2) ∩ HalfSpace([1, 2], 4) ∩ HalfSpace([-2, -1], 1) ∩ HalfSpace([1, -2], 2) ∩
    HalfSpace([1, 0], 2)

p = polyhedron(h)

p1 = contour(xlist, ylist, f, fill=true, line_smoothing=0.85)
plot(p1, opacity=0.5)
plot!(
    p,
    ratio=:equal,
    opacity=0.5,
    label=&quot;feasible region&quot;,
    framestyle=:zerolines,
    legend=true,
    color=:blue,
);</code></pre><p>Finally, we add all iterates and vertices to the plot.</p><pre><code class="language- hljs">colors = [&quot;gold&quot;, &quot;purple&quot;, &quot;darkorange2&quot;, &quot;firebrick3&quot;]
iterates = unique!(iterates)
for i in 1:3
    scatter!(
        [iterates[i][1]],
        [iterates[i][2]],
        label=string(&quot;x_&quot;, i - 1),
        markersize=6,
        color=colors[i],
    )
end
scatter!(
    [last(iterates)[1]],
    [last(iterates)[2]],
    label=string(&quot;x_&quot;, length(iterates) - 1),
    markersize=6,
    color=last(colors),
)</code></pre><p>plot chosen vertices</p><pre><code class="language- hljs">scatter!([vertices[1][1]], [vertices[1][2]], m=:diamond, markersize=6, color=colors[1], label=&quot;v_1&quot;)
scatter!(
    [vertices[2][1]],
    [vertices[2][2]],
    m=:diamond,
    markersize=6,
    color=colors[2],
    label=&quot;v_2&quot;,
    legend=:outerleft,
    colorbar=true,
)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../advanced/">« Advanced features</a><a class="docs-footer-nextpage" href="../docs_10_alternating_methods/">Alternating methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 19 October 2023 11:45">Thursday 19 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
